唯一key生成
数值型
-- 依靠时间，snowflake雪花算法(时间回拨问题，使用上一次生成的id顺推下去), UidGenerator预先分配id，弱依赖时间
-- 依靠数据库，数据库表sequence生成(无时间顺序)
字符型
-- UUID

幂等
-- 超时重试
-- 并发调用
方案:
1. MVVC(或唯一索引) 防止并发更新
2. 有限状态机 防止相同状态重复更新
3. 服务器端token申请，再用token来访问，支付领域常用
4. 请求带唯一的request id，request id落库判重， 如果新启一张表存在事务问题

异常重试
-- 异常识别
-- 稳定性

逆向
-- 事务回滚

数据一致性
一致性模型: 强一致性，单调一致性，会话一致性，最终一致性，弱一致性
            顺序一致性，线性一致性，因果一致性，读写一致性
-- 一阶段提交(Best Efforts 1PC,就是无协调者的普通事务)
刚性事务 ACID:
-- TXC分布式事务 二阶段提交(协调者和参与者发生两次完整的req-res交互)
    prepare -> submit
    缺点: 1. 协调者单点故障 2. 第二阶段某个参与者宕机不一致 3. 参与者超时阻塞，资源长期hold住
-- TXC分布式事务 三阶段提交(主要解决协调者单点和参与者超时阻塞的问题，增加超时控制和三个阶段交互)
    canCommit(询问是否可以执行，提前发现问题，超时导致失败) -> preCommit(二阶段的prepare，超时导致成功) -> doCommit(二阶段的submit)
    缺点: 1. 第三阶段某个参与者超时自动commit，实际上协调者发送了cancel(网络故障不可达, 脑裂)
-- TCC:(不阻塞资源，需要把接口一拆为三)
    try(锁定资源) -> confirm(更新资源) -> cancel(取消锁定资源)
-- Paxos协议
-- ZooKeeper ZAB协议(Paxos协议的改进)
-- Etcd Raft协议(Paxos协议的改进)
   1. start -> Follower -> Candidate -> Leader
   2. election term(election epoch), commitIndex(zxid)
   3. 选举结束后没有同步上一轮遗留的日志数据
   总结: ZAB和Raft本质上是一样的，实现细节不同
柔性事务 BASE:
-- 可靠消息
    1. 中间件使用half消息，保证发送端一致(发送端提供发送查询接口)
    2. 消息状态记录表发送者和接收者都对其进行更新,保证消费端一致(消费端提供消费查询接口)
    3. 发送端和接收端顺序消息的保证(未解决)
-- 事务补偿: 逆向接口, 线下日志补偿，线下消息补偿
-- 校对对账
-- 本地重试 -> writeAheadLog/DB记录任务状态(状态流转)
-- 状态流转: 每个操作都有一个对应的记录，维护记录的初始，已完成，已撤销等状态
-- 后置提交(大大减小不一致的几率，但是要加长hold住链接的时间)

解决分布式事务的最好办法就是不考虑分布式事务: 把分布式的事务过程拆解成多个中间状态，中间状态的东西不允许用户直接操作，
等状态都一致成功，或者检测到不一致的时候全部失败掉, 就解耦了这个强一致性的过程

系统稳定性
-- 降级
-- 超时熔断
-- 流量控制
1. 令牌桶
2. 滑动窗口
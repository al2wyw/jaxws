表达式求值:
1. 中缀表达式(通常人类识别的表达式，操作符在中间) -> 操作符栈， 结果栈(不好理解)  ->
后(前)缀表达式(计算机可以识别计算) -> 重新扫描后(前)缀表达式，借助单栈得到结果
前缀表达式对应于二叉树的前序遍历
中缀表达式对应于二叉树的中序遍历
后缀表达式对应于二叉树的后序遍历(一般用来构造二叉树，遍历后缀表达式，利用单栈)
2. 中缀表达式 -> 操作符栈(栈顶和入栈操作符使用优先级表比较优先级,栈顶较高则两个操作数出栈计算后再入操作数栈，操作符入栈，栈顶较低则直接入栈), 操作数栈(好理解) -> 结果
3. 递归实现

资源调度:


海量数据处理:(hash散列到不同的文件里???)
1.topK:
    1. heap排序
    2. 快速排序的partition实现随机减治(不同于分治)

2.bitset:
缺点:
    1. 现实对象无法很好的转换成数值，或容易出现相同的数值(hash)
    2. 如果数值比较离散不平均(1,2,3,4,9999999)，出现多个位点浪费(hash后取模限定位点大小，但是要解决重复)

3.bloomfilter:
    1. 实体目标数量，误判率 -> hash后需要取多少次值，位点大小
    2. 实体数量一定，hash取值次数越多，误判越低， 位点越多，误判越低
4.tier数(前缀树,字典树)
5.外排
6.mapReduce

排序:
1. 选择，插入，冒泡 -> n2
2. 希尔(插入的优化)，堆， 快速， 归并(n的空间) -> nlogn
3. 计数，桶(计数的优化)，基数(个位，十位，百位...) 空间都要n -> n+k

算法思想:
1. 贪心，分冶 -> 分解为子问题，子问题无重叠，各个子问题的解可以汇聚成问题的解
2. 动态规划 状态转移函数(需要避免重复计算) -> 分解为子问题，子问题重叠，互相影响(子问题最优化原理，最优子结构性质)
f[i][w] = f[i+1][w] ; wi > w
f[i][w] = max{f[i+1][w](i不选), f[i+1][w-wi]+vi(i选)}; wi < w
3. 回溯(深度优先 + 剪支)
4. 分支限界(广度优先 + 剪支) 上下界(一界合法合理(如贪心求得)，一界不合法不合理(不可达)) + 限界函数(计算当前节点的值，使用上下界剪支)

算法笔记:
将穷举遍历(时间复杂n)优化为常量遍历(使用set，map)(Q127)
先处理数据再解题，效率更高(Q18)
对复杂问题进行逻辑推导简化成简单问题(Q15)(Q1)
认真分析问题，跳出电脑程序思维，找到解决问题的关键点
反证法的例子可能是特例，最好多一些例子来反证(Q785 无法推导为有无环问题)

贪心算法思想: 局部最优+调整=全局最优
深度优先可以使用记忆化搜索避免重复计算(Q139)
广度优先可以解决最优(最少步骤)问题(每往下一层就是往前一步)，如果目标明确还可以双向广度优先(节点少的那端可以优先)(Q127)
动态规划如果是二维的dp数组记录最优子问题的解，可以使用一维数组进行空间优化(Q62)
动态规划要点(最优解或者多少解) -> 状态定义， 状态转移， 状态初始化： 定义dp[n]，初始化dp[0]，运算后答案为dp[n-1]
广度优先 和 动态规划 求解某些问题时可以使用状态压缩(二进制代表状态)来进行状态标识，需要使用位运算
最短路径可以使用DFS或者BFS，但是Dijkstra(地杰斯特拉)比较快
记忆化搜索与动态规划只是一种优化性能的手段，一个是自顶向下(从目标状态开始递归到初始状态)，一个是自底向上(从初始状态计算到目标)，记忆化搜索可能需要一个记录矩阵，但是动态规划有时可以采用滚动数组来减掉一维

动态规划 状态转移函数比较难推导(Q300, Q123)

数论算法
字符串匹配(kmp匹配)，前缀树(字典树)
图论(无向图: 最小生成树(无环图，n个顶点，n-1条边)，最短路径; 有向无环图(工程依赖相关)：拓扑排序AOV值在顶点(一般排序不唯一)，关键路径AOE值在边(最长路径))
Prime和Dijkstra类似(贪心算法)需要记录访问过的顶点和更新访问过的顶点到其他顶点的最小距离
拓扑排序使用队列，每次将入度(入向边的个数)为0的顶点入列，出列时把出列顶点指向的顶点的入度减1，如果队列为空时还有顶点没有访问到，则有环
需要数学公式推导的太难(最后的代码实现与问题相去甚远)，放弃(Q96,Q365)
TSP旅行家问题(np完全问题)(多项式求解问题) 从某个节点出发经过所有节点的最短路径 ???

链表操作全靠快慢双指针(滑动窗口) (Q142)
连续序列的前缀和 (Q523)
完全背包(每种石头无限个) -> 根据背包装载空间 -> 多重背包(每种石头有限个) -> 每种石头平铺开 -> 01背包(每种石头一个)

树形DP -> 父子节点冲突(Q337)
状压DP -> 玉米田的种法数量 F[i][j] = ∑ F[i-1][k] (j, k是二进制代表的状态，F[i][j]代表第i行状态为j的种法数量, 是i-1行各种合法状态k对应的种法的和)

动态规划有两种基本思路，一种是自顶向下的备忘录算法，它采用递归的方式，一步步缩小问题的规模，找到边界(n==0)以后，处理好边界，然后一步步返回，返回更大问题的解，
每获得一个子问题的答案，便保存到备忘录数组p[n][c]，避免下次重复计算，提升了效率。
另一种思路是自底向上的动态规划算法，它从最小的子问题(只包含0号物品)开始处理，然后依次增加可装物品的数量，用数组p[n][c]记录每一个已处理子问题的答案，由于01背包问题具有最优子结构，
每个问题的最优解都是由其子问题的最优解组成，故这样依次递增问题的规模，可以得到最终需要的最优解。
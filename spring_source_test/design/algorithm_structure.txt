表达式求值:
1. 中缀表达式(通常人类识别的表达式，操作符在中间) -> 操作符栈， 结果栈(不好理解)  ->
后(前)缀表达式(计算机可以识别计算) -> 重新扫描后(前)缀表达式，借助单栈得到结果
前缀表达式对应于二叉树的前序遍历
中缀表达式对应于二叉树的中序遍历
后缀表达式对应于二叉树的后序遍历(一般用来构造二叉树，遍历后缀表达式，利用单栈)
2. 中缀表达式 -> 操作符栈(栈顶和入栈操作符使用优先级表比较优先级,栈顶较高则两个操作数出栈计算后再入操作数栈，操作符入栈，栈顶较低则直接入栈), 操作数栈(好理解) -> 结果
3. 递归实现

资源调度:


海量数据处理:(hash散列到不同的文件里???)
1.topK:
    1. heap排序
    2. 快速排序的partition实现随机减治(不同于分治)

2.bitset:
缺点:
    1. 现实对象无法很好的转换成数值，或容易出现相同的数值(hash)
    2. 如果数值比较离散不平均(1,2,3,4,9999999)，出现多个位点浪费(hash后取模限定位点大小，但是要解决重复)

3.bloomfilter:
    1. 实体目标数量，误判率 -> hash后需要取多少次值，位点大小
    2. 实体数量一定，hash取值次数越多，误判越低， 位点越多，误判越低
4.tier数(前缀树,字典树)
5.外排
6.mapReduce

排序:
1. 选择，插入，冒泡 -> n2
2. 希尔(插入的优化)，堆， 快速， 归并(n的空间) -> nlogn
3. 计数，桶(计数的优化)，基数(个位，十位，百位...) 空间都要n -> n+k

算法思想:
1. 贪心，分冶 -> 分解为子问题，子问题无重叠，各个子问题的解可以汇聚成问题的解
2. 动态规划 状态转移函数(需要避免重复计算) -> 分解为子问题，子问题重叠，互相影响(子问题最优化原理，最优子结构性质)
f[i][w] = f[i+1][w] ; wi > w
f[i][w] = max{f[i+1][w](i不选), f[i+1][w-wi]+vi(i选)}; wi < w
3. 回溯(深度优先 + 剪支)
4. 分支限界(广度优先 + 剪支) 上下界(一界合法合理(如贪心求得)，一界不合法不合理(不可达)) + 限界函数(计算当前节点的值，使用上下界剪支)


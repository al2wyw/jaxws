RootBeanDefinition -> ConfigurationClassBeanDefinition(AnnotatedBeanDefinition)
GenericBeanDefinition -> ScannedGenericBeanDefinition(AnnotatedBeanDefinition)/AnnotatedGenericBeanDefinition(AnnotatedBeanDefinition)
ConfigurationClassBeanDefinition 来自@Configuration的Class中的bean method创建
ScannedGenericBeanDefinition 来自scan机制扫描创建(functionally equivalent to AnnotatedGenericBeanDefinition)
AnnotatedGenericBeanDefinition 是AnnotatedBeanDefinition的缺省实现，所有的被标注的类都可以创建 (@Import的class)
RootBeanDefinition: A root bean definition represents the merged bean definition,It might have been created from multiple original bean definitions that inherit from each other(worked with ChildBeanDefinition)
GenericBeanDefinition: registering user-visible bean definitions (which a post-processor might operate on, potentially even reconfiguring the parent name).
RootBeanDefinition 有很多奇怪的属性 ??? GenericBeanDefinition 就没有，可能不需要关心， 只要关心AbstractBeanDefinition的属性就可以了

beanPostProcessors list is inside AbstractBeanFactory while beanFactoryPostProcessors list is inside AbstractApplicationContext
DefaultListableBeanFactory beanFactory is inside AbstractRefreshableApplicationContext
	
beanFactory.ignoreDependencyInterface(ApplicationContextAware.class)??? see ApplicationContextAwareProcessor
beanFactory.registerResolvableDependency(ApplicationContext.class, beanFactory)???

InstantiationStrategy(default ctor,ctor,factory method) -> SimpleInstantiationStrategy -> CglibSubclassingInstantiationStrategy

FactoryBean is used in BeanFactory(getObjectForBeanInstance) while ObjectFactory is a normal object generator(used in dependency injection), they are similar.

Bug ? Indexer will change Properties to Map and get value from a Map. see getValue of MapIndexingValueRef in Indexer.
However, Properties has a default Properties which created by Properties(Properties default), when Properties can not get 
the value, it will query from default Properties. Map will not do this!

useful utils:
org.springframework.beans.BeanUtils, org.springframework.util.ClassUtils

CglibSubclassingInstantiationStrategy is used by method-overrides to instatiate bean

getLazyResolutionProxyIfNecessary what does the xml do with this (just instantiate the bean later, and then let it pass through all the beanPostProcessors)

@Lazy with @Autowired will create lazyProxy, but the target should be tagged with @Lazy to instantiate later. @Lazy with aop getTarget (jdk/cglib) 

getBean has three args: beanname, args, classtype. always use beanname or beanname plus classtype  !!!
before getBean it will have condition judgement

Autowire use DependencyDescriptor(do not check the metaAnnotaion), ConfigClass use AnnotationMetadata(AnnotationMetadataReadingVisitor metaAnnotationMap and attributesMap have metaAnnotaion)

DecoratedDefinition qualifiedElement ???

program format:
shortcut
fallback

addSingleton(String beanName, Object singletonObject) {
		synchronized (this.singletonObjects) {
			this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
			this.singletonFactories.remove(beanName);
			this.earlySingletonObjects.remove(beanName);//!!!
			this.registeredSingletons.add(beanName);
		}
	}
addSingletonFactory(String beanName, ObjectFactory singletonFactory) {
		Assert.notNull(singletonFactory, "Singleton factory must not be null");
		synchronized (this.singletonObjects) {
			if (!this.singletonObjects.containsKey(beanName)) {
				this.singletonFactories.put(beanName, singletonFactory);
				this.earlySingletonObjects.remove(beanName);//!!!
				this.registeredSingletons.add(beanName);
			}
		}
	}
	
spring startup:

org.springframework.web.context.ContextLoaderListener extends org.springframework.web.context.ContextLoader implements ServletContextListener{
	public void contextInitialized ( ServletContextEvent sce ){
		ContextLoader.initWebApplicationContext(ServletContext servletContext){
			this.context = createWebApplicationContext(servletContext){
				determineContextClass(servletContext){
					String contextClassName = servletContext.getInitParameter("contextClass");
					determine the application context, the default will be XmlWebApplicationContext
				}
			}
			if this.context instanceof ConfigurableWebApplicationContext {
				setParent:loadParentContext(servletContext){
					servletContext.getInitParameter(LOCATOR_FACTORY_KEY_PARAM)
					if LOCATOR_FACTORY_KEY_PARAM is not set by web.xml, no parent!
				}
				configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc){
					wac.setId: getInitParameter(CONTEXT_ID_PARAM)
					wac.setServletContext: sc
					wac.setConfigLocation:getInitParameter(CONFIG_LOCATION_PARAM)
					customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext){
						determineContextInitializerClasses(servletContext){ (used for extension)
							getInitParameter(CONTEXT_INITIALIZER_CLASSES_PARAM)
							ApplicationContextInitializer class name is spilt by ","
						}
						ApplicationContextInitializer<C extends ConfigurableApplicationContext> has: void initialize(C applicationContext) will be called
					}
					wac.refresh();
				}
			}
			servletContext.setAttribute(WebApplicationContext.class.getName() + ".ROOT", this.context);
			return this.context;
		}
	}
}

AbstractApplicationContext.refresh(){
	// Prepare this context for refreshing.
	prepareRefresh()

	// Tell the subclass to refresh the internal bean factory.
	ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(){
		AbstractRefreshableApplicationContext.refreshBeanFactory(){
			if hasBeanFactory() {
				destroyBeans()
				closeBeanFactory()
			}
			DefaultListableBeanFactory beanFactory = createBeanFactory()
			beanFactory.setSerializationId(getId())
			customizeBeanFactory(beanFactory) (used for extension)
			XmlWebApplicationContext.loadBeanDefinitions(beanFactory){
				XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
				initialize beanDefinitionReader
				loadBeanDefinitions(beanDefinitionReader){
					load the resources from configLocation
					XmlBeanDefinitionReader,GroovyBeanDefinitionReader,PropertiesBeanDefinitionReader
					XmlBeanDefinitionReader.loadBeanDefinitions(resource){
						Document doc = doLoadDocument(inputSource, resource);
						return registerBeanDefinitions(doc,resource){
							DefaultBeanDefinitionDocumentReader and BeanDefinitionParserDelegate are two important classes for parsing bean definitions
							registerBeanDefinitions(DefaultBeanDefinitionDocumentReader){
								doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader){
									preProcessXml (used for extension)
									parseBeanDefinitions(DefaultBeanDefinitionDocumentReader){
										//the properties of ParserContext are important
										parseDefaultElement(DefaultBeanDefinitionDocumentReader);
										parseCustomElement(BeanDefinitionParserDelegate);
									}
									postProcessXml (used for extension)
								}
							}
						}
					}
				}
			}
			this.beanFactory = beanFactory;
		}
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
		return beanFactory
	}

	// Prepare the bean factory for use in this context.
	prepareBeanFactory(beanFactory){
		beanFactory.setBeanClassLoader(getClassLoader());
		beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver());
		beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

		// Configure the bean factory with context callbacks.
		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);

		// BeanFactory interface not registered as resolvable type in a plain factory.
		// MessageSource registered (and found for autowiring) as a bean.
		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
		beanFactory.registerResolvableDependency(ResourceLoader.class, this);
		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
		beanFactory.registerResolvableDependency(ApplicationContext.class, this);
		//no MessageSource, because it is registered as a bean

		// Detect a LoadTimeWeaver and prepare for weaving, if found.
		if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			// Set a temporary ClassLoader for type matching.
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}

		// Register default environment beans.
		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
		}
	}

	// Allows post-processing of the bean factory in context subclasses.
	postProcessBeanFactory(beanFactory)(AbstractRefreshableWebApplicationContext){
		addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext, this.servletConfig));
	}

	// create BeanFactoryPostProcessor via getBean
	// Invoke factory processors registered as beans in the context.
	invokeBeanFactoryPostProcessors(beanFactory)(AbstractApplicationContext){
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());{
			if (beanFactory instanceof BeanDefinitionRegistry){
				convert beanFactory to registry 
				//the beanFactoryPostProcessors in AbstractApplicationContext is empty at the beginning
				//but if there are some BeanDefinitionRegistryPostProcessors in AbstractApplicationContext, 
				//it should not in BeanDefinitionRegistry and SingletonBeanRegistry otherwise it will be called twice!!!
				splite beanFactoryPostProcessors into registryPostProcessors and regularPostProcessors and call registryPostProcessor.postProcessBeanDefinitionRegistry(registry) first
				
				//do not introduce the BeanDefinitionRegistryPostProcessor in the same group, otherwise it will be processed as the next group
				String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);{
					比较复杂 ???
					if (!isConfigurationFrozen()  || type == null || !allowEagerInit) {
						return doGetBeanNamesForType(Class<?> type, boolean includeNonSingletons, boolean allowEagerInit){
							// Check all bean definitions.
							
							// Check manually registered singletons.
						}
					}
					//check the cache and then call doGetBeanNamesForType and cache the result
				}
				for (String ppName : postProcessorNames) {
					if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
						priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
						processedBeans.add(ppName);
					}
				}
				OrderComparator.sort(priorityOrderedPostProcessors);
				registryPostProcessors.addAll(priorityOrderedPostProcessors);
				invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);
				
				beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
				if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
					orderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
				OrderComparator.sort(orderedPostProcessors);
				registryPostProcessors.addAll(orderedPostProcessors);
				invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);
				
				//the rest
				while (reiterate) {
					reiterate = false;
					postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
					for (String ppName : postProcessorNames) {
						if (!processedBeans.contains(ppName)) {
							BeanDefinitionRegistryPostProcessor pp = beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class);
							registryPostProcessors.add(pp);
							processedBeans.add(ppName);
							pp.postProcessBeanDefinitionRegistry(registry);
							reiterate = true;
						}
					}
				}
				
				// private invokeBeanFactoryPostProcessors of this delegate
				invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);
				invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);//regularPostProcessors may be empty
			}else{
				invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
			}
			
			String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
			skip the processedBeans and spilt postProcessorNames into three groups:
			OrderComparator.sort(priorityOrderedPostProcessors);
			invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);
			OrderComparator.sort(orderedPostProcessors);
			invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);
			invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
		}
	}

	// create BeanPostProcessor via getBean
	// Register bean processors that intercept bean creation.
	registerBeanPostProcessors(beanFactory){
		PostProcessorRegistrationDelegate.registerBeanPostProcessors{
			postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);
			int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
			beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));{	
				this.beanPostProcessors.remove(beanPostProcessor);
				this.beanPostProcessors.add(beanPostProcessor);
			}

			spilt them into three groups and if it is MergedBeanDefinitionPostProcessor then internalPostProcessors.add(pp);
			OrderComparator.sort(priorityOrderedPostProcessors);
			registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);
			OrderComparator.sort(orderedPostProcessors);
			registerBeanPostProcessors(beanFactory, orderedPostProcessors);
			registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);
			OrderComparator.sort(internalPostProcessors);
			registerBeanPostProcessors(beanFactory, internalPostProcessors);//why register them twice ??? see addBeanPostProcessor
			
			beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
		}
	}

	// Initialize message source for this context.
	initMessageSource();

	// Initialize event multicaster for this context.
	initApplicationEventMulticaster();

	// Initialize other special beans in specific context subclasses.
	onRefresh();(used for extension)

	// Check for listener beans and register them.
	registerListeners();

	// Instantiate all remaining (non-lazy-init) singletons.
	finishBeanFactoryInitialization(beanFactory){
		// Initialize conversion service for this context.
		if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
			beanFactory.setConversionService(
					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
		}

		// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
		for (String weaverAwareName : weaverAwareNames) {
			getBean(weaverAwareName);
		}

		// Stop using the temporary ClassLoader for type matching.
		beanFactory.setTempClassLoader(null);

		// Allow for caching all bean definition metadata, not expecting further changes.
		beanFactory.freezeConfiguration();

		// Instantiate all remaining (non-lazy-init) singletons.
		beanFactory.preInstantiateSingletons(){
			for (String beanName : beanNames) {
				RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
				if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
					if (isFactoryBean(beanName)) {
						final FactoryBean<?> factory = (FactoryBean<?>) getBean("&" + beanName);
						boolean isEagerInit = (factory instanceof SmartFactoryBean && ((SmartFactoryBean<?>) factory).isEagerInit());
						if (isEagerInit) { //EagerInit is special setup only within SmartFactoryBean, normal FactoryBean expects to initialize when being accessed
							getBean(beanName);
						}
					}else{
						getBean(beanName);
					}
				}
			}
			for (String beanName : beanNames) {
				Object singletonInstance = getSingleton(beanName);
				if (singletonInstance instanceof SmartInitializingSingleton) {
					final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
					smartSingleton.afterSingletonsInstantiated();
				}
			}
		}
	}

	// Last step: publish corresponding event.
	finishRefresh();

	no resourceLoader? because AbstractApplicationContext extends DefaultResourceLoader!
}
	
	DefaultBeanDefinitionDocumentReader.parseDefaultElement(){												
		importBeanDefinitionResource(DefaultBeanDefinitionDocumentReader);//IMPORT_ELEMENT
		processAliasRegistration(DefaultBeanDefinitionDocumentReader);//ALIAS_ELEMENT
		processBeanDefinition(DefaultBeanDefinitionDocumentReader){//BEAN_ELEMENT
			BeanDefinitionHolder bdHolder = parseBeanDefinitionElement(BeanDefinitionParserDelegate){
				...
				id -> beanName; name -> alias; BeanDefinitionHolder holds beanName, alias and BeanDefinition
			}
			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()){
				Registry is actually DefaultListableBeanFactory!!!
				registerBeanDefinition(DefaultListableBeanFactory)
			}
		}
		doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader);//BEANS_ELEMENT
	}
	BeanDefinitionParserDelegate.parseCustomElement(){
		//here to deal with "context:component-scan" 
		NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri){
			resolve function will put the related parsers into handlerMappings of DefaultNamespaceHandlerResolver
			//map namespaceUri to handlerClass from property file
			NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);
			namespaceHandler.init();//important
			handlerMappings.put(namespaceUri, namespaceHandler);
			return namespaceHandler;
		}
		handler.parse(NamespaceHandlerSupport){
			BeanDefinitionParser parser = findParserForElement{
				String localName = parserContext.getDelegate().getLocalName(element);
				BeanDefinitionParser parser = this.parsers.get(localName);
			}
			return parser.parse();
		}
	}
	
------------------BeanDefinitionParser list start----------------------------------
	ComponentScanBeanDefinitionParser.parse(){
		String[] basePackages = splite from config string
		//create ClassPathBeanDefinitionScanner with default typeFilter (ClassPathScanningCandidateComponentProvider#registerDefaultFilters)
		ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); 
		Set<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);{
			Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<BeanDefinitionHolder>();
			for (String basePackage : basePackages) {
				Set<BeanDefinition> candidates = findCandidateComponents(basePackage)(ClassPathScanningCandidateComponentProvider){
					Set<BeanDefinition> candidates = new LinkedHashSet<BeanDefinition>();
					Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
					for (Resource resource : resources) {
						if resource.isReadable{
						MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource){
							new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader()){
								classReader = new ClassReader(is);
								//StandardAnnotationMetadata is java reflect implementation, while AnnotationMetadataReadingVisitor is spring implementation
								AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader);
								classReader.accept(visitor, ClassReader.SKIP_DEBUG);
								this.annotationMetadata = visitor;
								this.classMetadata = visitor;
								this.resource = resource;
							}
						}
						if isCandidateComponent(metadataReader){
							ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
							sbd.setResource(resource);
							sbd.setSource(resource);
							if (isCandidateComponent(sbd))//verify whether AnnotationMetadata of sbd is concrete(not interface/abstract) and independent(outer class or static inner class) !!!
								candidates.add(sbd);
						}
						}
					}
					return candidates;
				}
			
				for (BeanDefinition candidate : candidates) {
					//@Scope to make scoped-proxy with proxyMode or other scopes with value
					ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
					candidate.setScope(scopeMetadata.getScopeName());
					//get the bean name
					String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
					if (candidate instanceof AbstractBeanDefinition) {
						postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);{
							beanDefinition.applyDefaults(this.beanDefinitionDefaults); //BeanDefinitionParserDelegate.populateDefaults setup defaults
							beanDefinition.setAutowireCandidate(PatternMatchUtils.simpleMatch(this.autowireCandidatePatterns, beanName));
						}
					}
					if (candidate instanceof AnnotatedBeanDefinition) {
						AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);{
							deal with @Primary, @Lazy, @DependsOn, @Role
						}
					}
					if (checkCandidate(beanName, candidate)){// if !this.registry.containsBeanDefinition(beanName) return true, else check definition conflict
						BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
						definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);//createScopedProxy according to scopedProxyMode of scopeMetadata
						beanDefinitions.add(definitionHolder);
						registerBeanDefinition(definitionHolder, this.registry);
					}
				}
			}
			return beanDefinitions;
		}
		registerComponents(parserContext.getReaderContext(), beanDefinitions, element);(ComponentScanBeanDefinitionParser){
			compositeDef.addNestedComponent(new BeanComponentDefinition(beanDefHolder));//no effect
			if annotationConfig{
				AnnotationConfigUtils.registerAnnotationConfigProcessors
				compositeDef.addNestedComponent(new BeanComponentDefinition(processorDefinition));//no effect
			}
			readerContext.fireComponentRegistered(compositeDef);//do nothing!!!
		}
	}
	protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
		for (TypeFilter tf : this.excludeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) return false;
		}
		for (TypeFilter tf : this.includeFilters) {
			if (tf.match(metadataReader, this.metadataReaderFactory)) return isConditionMatch(metadataReader);//isConditionMatch to use @Conditional, no @Conditional at all return true
		}
		return false;
	}
	public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)(AbstractTypeHierarchyTraversingFilter){
		//matchSelf of AnnotationTypeFilter will check annotationSet and metaAnnotationMap of AnnotationMetadataReadingVisitor
		if (matchSelf(metadataReader)) return true;
		ClassMetadata metadata = metadataReader.getClassMetadata();
		if (matchClassName(metadata.getClassName())) return true;
		if (this.considerInherited) {...}
		if (this.considerInterfaces) {...}
		return false;
	}
	AspectJAutoProxyBeanDefinitionParser.parse(){
	}
	ConfigBeanDefinitionParser.parse(){
		to create DefaultBeanFactoryPointcutAdvisor and AspectJPointcutAdvisor advisors
	}
	AnnotationDrivenBeanDefinitionParser.parse(){
		if ("aspectj".equals(mode)) {
			registerTransactionAspect(element, parserContext);
		}
		else {
			// BeanFactoryTransactionAttributeSourceAdvisor has TransactionAttributeSourcePointcut
			// TransactionAttributeSourcePointcut will match whether the target has @Transactional
			AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);{
				AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);{
					BeanDefinition beanDefinition = AopConfigUtils.registerAutoProxyCreatorIfNecessary(
							parserContext.getRegistry(), parserContext.extractSource(sourceElement));{
								//actually did not register or escalate and return null;
								return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);
							}
					//if proxyTargetClass is true
					useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);
					//if beanDefinition is null, did not register it
					registerComponentIfNecessary(beanDefinition, parserContext);
				}
				//txAdvisorBeanName = "org.springframework.transaction.config.internalTransactionAdvisor"
				if (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) {
					// Create the TransactionAttributeSource definition.
					RootBeanDefinition sourceDef = new RootBeanDefinition(
						"org.springframework.transaction.annotation.AnnotationTransactionAttributeSource");
					setup sourceDef
					String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef);
					
					// Create the TransactionInterceptor definition.
					RootBeanDefinition interceptorDef = new RootBeanDefinition(TransactionInterceptor.class);
					setup interceptorDef
					interceptorDef.getPropertyValues().add("transactionManagerBeanName","transactionManager");
					interceptorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
					//interceptorName "packageName.TransactionInterceptor#0"
					String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);
					
					// Create the TransactionAttributeSourceAdvisor definition.
					RootBeanDefinition advisorDef = new RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);
					setup advisorDef
					advisorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
					//will then retrieve by getBean("adviceBeanName") of getAdvice
					advisorDef.getPropertyValues().add("adviceBeanName", interceptorName);
					if hasAttribute("order")
						advisorDef.getPropertyValues().add("order", element.getAttribute("order"));
					parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);
					
					//put component into compDefinition
					parserContext.registerComponent
				}
			}
		}
	}
	//tx manager parser:
	AbstractBeanDefinitionParser.parse(){
		AbstractSingleBeanDefinitionParser.parseInternal(){
			...
			Class<?> beanClass = getBeanClass(element);//tx:advice return TransactionInterceptor.class
			if (beanClass != null) {
				builder.getRawBeanDefinition().setBeanClass(beanClass);
			}
			TxAdviceBeanDefinitionParser.doParse(){
				...
				parseAttributeSource(){
					...
					RootBeanDefinition attributeSourceDefinition = new RootBeanDefinition(NameMatchTransactionAttributeSource.class);
					attributeSourceDefinition.setSource(parserContext.extractSource(attrEle));
					attributeSourceDefinition.getPropertyValues().add("nameMap", transactionAttributeMap);
					return attributeSourceDefinition;
				}
				...
			}
			...
		}
		String id = resolveId(element, definition, parserContext);//tx:advice return transactionAdvice
	}
	AnnotationDrivenBeanDefinitionParser.parse(){
		//compDefinition's name is mvc:annotation-driven
		parserContext.pushContainingComponent(compDefinition);
		
		//getRegistry().registerBeanDefinition
		parserContext.getReaderContext().registerWithGeneratedName
		
		//put component into compDefinition
		parserContext.registerComponent
	}
------------------BeanDefinitionParser list end----------------------------------

---------------------createBean start----------------------------------
getBean Process Flow:
1. getSingleton -> getObjectForBeanInstance
2. parentBeanFactory.getBean
3. getBean(dependsOn)
4. createBean -> getObjectForBeanInstance
4.1. resolveBeforeInstantiation
4.2. createBeanInstance
4.3. postProcessMergedBeanDefinition
...
Difficulties: ConstructorResolver

	AbstractBeanFactory.getBean(String beanName){
		doGetBean(name, null, null, false)(String name, Class<T> requiredType, Object[] args, boolean typeCheckOnly){
			//当配置文件中<bean>的class属性配置的实现类是FactoryBean时，通过getBean()方法返回的不是FactoryBean本身，
            //而是FactoryBean#getObject()方法所返回的对象, 如果希望获取FactoryBean的实例，需要在beanName前加上“&”符号，即getBean("&beanName")
			final String beanName = transformedBeanName(name);//在这里要获取的是bean的实例，所以要去掉&符号
			
			// EarlyBeanReference will be added in doCreateBean(addSingletonFactory), and then BeanDefinitionValueResolver.resolveReference will call getSingleton to retrieve the EarlyBeanReference to solve the circle reference
			sharedInstance = getSingleton(beanName,true)(DefaultSingletonBeanRegistry){ // important!!!
				Object singletonObject = this.singletonObjects.get(beanName);
				if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { //singletonsCurrentlyInCreation.contains(beanName)
					synchronized (this.singletonObjects) {
						singletonObject = this.earlySingletonObjects.get(beanName);
						if (singletonObject == null && allowEarlyReference) {
							singletonObject = this.singletonFactories.get(beanName).getObject(); // see addSingletonFactory
							this.earlySingletonObjects.put(beanName, singletonObject);
							this.singletonFactories.remove(beanName);
						}
					}
				}
				return (singletonObject != NULL_OBJECT ? singletonObject : null);
			}
			if (sharedInstance != null && args == null) {
				bean = getObjectForBeanInstance(sharedInstance, name, beanName, null){ //get either the bean instance or created object of a FactoryBean
					if not a FactoryBean return sharedInstance else
					getObjectFromFactoryBean(FactoryBeanRegistrySupport){
						/** Cache of singleton objects created by FactoryBeans: FactoryBean name --> object */
						Object object = this.factoryBeanObjectCache.get(beanName);
						object = doGetObjectFromFactoryBean(FactoryBeanRegistrySupport){
							object = factory.getObject();
							//no other beanPostProcessor !!!
							postProcessObjectFromFactoryBean(AbstractAutowireCapableBeanFactory){ // important!!!
								//may be wrapIfNecessary to create proxy (AbstractAutoProxyCreator)
								applyBeanPostProcessorsAfterInitialization
							}
						}
						this.factoryBeanObjectCache.put
					}
				}
			}else {
				//check parent first!
				BeanFactory parentBeanFactory = getParentBeanFactory();
				if parentBeanFactory != null && !containsBeanDefinition(beanName) //this.beanDefinitionMap.containsKey(beanName);
					// Not found -> check parent.
					return parentBeanFactory.getBean
				
				markBeanAsCreated(beanName) // ignore
				
				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);{
					return getMergedBeanDefinition(beanName, getBeanDefinition(beanName), null);//getBeanDefinition -> beanDefinitionMap.get(beanName)
					return getMergedBeanDefinition(String beanName, BeanDefinition bd, BeanDefinition containingBd){
						if (containingBd == null) mbd = this.mergedBeanDefinitions.get(beanName);
						if (mbd == null) {
							if (bd.getParentName() == null) {
								if (bd instanceof RootBeanDefinition) {
									mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();
								}else {
									mbd = new RootBeanDefinition(bd);
								}
							}else {
								BeanDefinition pbd;// Child bean definition: needs to be merged with parent.
								String parentBeanName = transformedBeanName(bd.getParentName()); //去除"&", 如果是FactoryBean
								if (!beanName.equals(parentBeanName)) {
									pbd = getMergedBeanDefinition(parentBeanName);
								}else {
									BeanFactory parent = getParentBeanFactory();
									if (parent instanceof ConfigurableBeanFactory) {
										pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);
									}else {
										throw new NoSuchBeanDefinitionException();
									}
								}
								// Deep copy with overridden values.
								mbd = new RootBeanDefinition(pbd);
								mbd.overrideFrom(bd);
							}

							if (!StringUtils.hasLength(mbd.getScope())) mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);
							if (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) mbd.setScope(containingBd.getScope());
							if (containingBd == null && isCacheBeanMetadata()) this.mergedBeanDefinitions.put(beanName, mbd);
						}
						return mbd;
					}
				}
				String[] dependsOn = mbd.getDependsOn()
				for (String dependsOnBean : dependsOn) {
					//dependentBean depends on bean
					//will also check the transitiveDependency
					if (isDependent(beanName, dependsOnBean)) {
						throw new BeanCreationException("Circular depends-on relationship between '" +
								beanName + "' and '" + dependsOnBean + "'");
					}
					registerDependentBean(dependsOnBean, beanName);
					getBean(dependsOnBean);
				}
				
				if (mbd.isSingleton()) {
					sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
						
						public Object getObject() throws BeansException {
							try {
								return createBean(beanName, mbd, args);	
							}
							catch (BeansException ex) {
								// Explicitly remove instance from singleton cache: It might have been put there
								// eagerly by the creation process, to allow for circular reference resolution.
								// Also remove any beans that received a temporary reference to the bean.
								destroySingleton(beanName);
								throw ex;
							}
						}
					}){
						synchronized (this.singletonObjects) {
							Object singletonObject = this.singletonObjects.get(beanName);
							if (singletonObject == null) {
								beforeSingletonCreation -> singletonsCurrentlyInCreation.add
								singletonObject = singletonFactory.getObject(); //singletonFactory is ObjectFactory
								afterSingletonCreation -> singletonsCurrentlyInCreation.remove
								addSingleton(beanName, singletonObject)
							}
						}
					}
					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}else if (mbd.isPrototype()) {
					createBean
					getObjectForBeanInstance
				}else{ //other scope registered
					createBean
					getObjectForBeanInstance
				}
			}
			if (requiredType != null && bean != null && !requiredType.isInstance(bean)) {
				return getTypeConverter().convertIfNecessary(bean, requiredType);
			}
			return bean;
		}
	}
	AbstractAutowireCapableBeanFactory.createBean(beanName, mbd, args){
		creates a bean instance, populates the bean instance, applies post-processors, etc
		
		// Make sure bean class is actually resolved at this point. resolve class name to real class object
		resolveBeanClass(mbd, beanName);
		
		//method look-up overrides
		mbd.prepareMethodOverrides();

		// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
		bean = resolveBeforeInstantiation(AbstractAutowireCapableBeanFactory){ // important!!!
			if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
				Class<?> targetType = determineTargetType(beanName, mbd);
				if (targetType != null) {
					bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);//must setup custom source target at first -> createProxy (AbstractAutoProxyCreator)
					if (bean != null) bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
				}
			}
		}
		if (bean != null) {
			return bean;
		}
		Object beanInstance = doCreateBean(beanName, mbdToUse, args)(AbstractAutowireCapableBeanFactory){
			/** Cache of unfinished FactoryBean instances: FactoryBean name --> BeanWrapper */
			BeanWrapper instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
			if instanceWrapper == null -> instanceWrapper = createBeanInstance(beanName, mbd, args){
				//using an appropriate instantiation strategy:factory method, constructor autowiring, or simple instantiation
				
				// Make sure bean class is actually resolved at this point.
				Class<?> beanClass = resolveBeanClass(mbd, beanName);
				
				//normally, args is null, please notice the condition of different methods to be called
				if (mbd.getFactoryMethodName() != null){
					//查看RootBeanDefinition的factor-method属性是不是空的，不为空，说明bean 
					//要通过先实例化对应的factoryBean然后调用factoryMethod方法实现，或者直接调用静态的factoryMethod方法
					instantiateUsingFactoryMethod(beanName, mbd, args){
						return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs){// @Bean
							...
						}
					}
				}
				// Shortcut when re-creating the same bean... (prototype or other scopes)
				boolean resolved = false;
				boolean autowireNecessary = false;
				if (args == null) {//explicit args is null so use constructor argument values from bean definition
					synchronized (mbd.constructorArgumentLock) {
						if (mbd.resolvedConstructorOrFactoryMethod != null) {
							resolved = true;
							autowireNecessary = mbd.constructorArgumentsResolved;
						}
					}
				}
				if (resolved) {
					if (autowireNecessary) {
						return autowireConstructor(beanName, mbd, null, null);
					}
					else {
						return instantiateBean(beanName, mbd);
					}
				}
				
				//Determine candidate constructors to use, checking all registered BeanPostProcessors
				Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);{
					ctors = SmartInstantiationAwareBeanPostProcessor.determineCandidateConstructors(beanClass, beanName);//AutowiredAnnotationBeanPostProcessor
					if (ctors != null) {
						return ctors;
					}
				}
				
				//ctors, AUTOWIRE_CONSTRUCTOR, constructor-arg, args
				if (ctors != null ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)){
					return autowireConstructor(beanName, mbd, ctors, args){
						new ConstructorResolver(this).autowireConstructor(beanName, mbd, chosenCtors, explicitArgs){
							BeanWrapperImpl bw = new BeanWrapperImpl();
							this.beanFactory.initBeanWrapper(bw);
							
							if (explicitArgs != null) {
								argsToUse = explicitArgs;
							}else {
								Object[] argsToResolve = null;
								synchronized (mbd.constructorArgumentLock) {
									constructorToUse = (Constructor<?>) mbd.resolvedConstructorOrFactoryMethod;
									if (constructorToUse != null && mbd.constructorArgumentsResolved) {
										argsToUse = mbd.resolvedConstructorArguments;
										if (argsToUse == null) {
											argsToResolve = mbd.preparedConstructorArguments;
										}
									}
								}
								if (argsToResolve != null) {
									argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);{
										//resolve the args, too complex ???
										BeanDefinitionValueResolver.resolveValueIfNecessary
										... ???
									}
								}
							}
							
							//ctors is null for not autowireanotation and explicitArgs is allways null
							if (constructorToUse == null) {
								//determine the constructor to use, too complex ???
								minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues){
										//Resolve the constructor arguments for this bean.
										//This may involve looking up other beans.
										BeanDefinitionValueResolver.resolveValueIfNecessary
								}
								... ???
							}
							beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
							bw.setWrappedInstance(beanInstance);
							return bw;
						}
					}
				}
				
				return instantiateBean(beanName, mbd){
					beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);{//SimpleInstantiationStrategy
								if (bd.getMethodOverrides().isEmpty()) {
									constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;
									if (constructorToUse == null) {
										final Class<?> clazz = bd.getBeanClass();
										if (clazz.isInterface()) throw new BeanInstantiationException(clazz, "Specified class is an interface");
										constructorToUse =	clazz.getDeclaredConstructor((Class[]) null);
										bd.resolvedConstructorOrFactoryMethod = constructorToUse;
									}
									return BeanUtils.instantiateClass(constructorToUse);
								}else{
									// Must generate CGLIB subclass.
									return instantiateWithMethodInjection(bd, beanName, owner);
								}
							}
					BeanWrapper bw = new BeanWrapperImpl(beanInstance);
					initBeanWrapper(bw){
						bw.setConversionService(getConversionService());
						registerCustomEditors(bw);
					}
					return bw;
				}
			}
			
			final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
			Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);
			// important!!!
			applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); // MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition(mbd, beanType, beanName);
			
			boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences && isSingletonCurrentlyInCreation(beanName));
			if earlySingletonExposure -> addSingletonFactory(beanName, new ObjectFactory<Object>() { // important!!!
												@Override
												public Object getObject() throws BeansException {
													return getEarlyBeanReference(beanName, mbd, bean){
														Object exposedObject = bean;
														if (bean != null && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
															for (BeanPostProcessor bp : getBeanPostProcessors()) {
																if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
																	SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
																	exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName); // wrapIfNecessary to create proxy (AbstractAutoProxyCreator)
																	if (exposedObject == null) -> return null;	
																}
															}
														}
														return exposedObject;
													}
												}
											});
			Object exposedObject = bean;
			//setup all the properties
			populateBean(beanName, mbd, instanceWrapper);
			//exposedObject may be changed to a proxy
			if (exposedObject != null) {
				exposedObject = initializeBean(beanName, exposedObject, mbd);
			}
			
			//if the bean is early referenced and it is a proxy, this will get the proxy.
			if (earlySingletonExposure){
				Object earlySingletonReference = getSingleton(beanName, false);
				if (earlySingletonReference != null) {
					if (exposedObject == bean) -> exposedObject = earlySingletonReference;
				}else if(!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)){
					???
				}
			}
			
			registerDisposableBeanIfNecessary(beanName, bean, mbd);{
				//do not care about prototype
				if (!mbd.isPrototype() && requiresDestruction(bean, mbd)) { // hasDestroyMethod || hasApplicableBeanPostProcessors
					if (mbd.isSingleton()) { // disposableBeans is within DefaultSingletonBeanRegistry
						disposableBeans.put(beanName, new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
					}else{
						// A bean with a custom scope...
						scope.registerDestructionCallback
					}
				}
			}
			return exposedObject;
		}
		return beanInstance;
	}
	DisposableBeanAdapter implements DisposableBean, Runnable{
		public void destroy() { // called by DefaultSingletonBeanRegistry.destroyBean
			if (!CollectionUtils.isEmpty(this.beanPostProcessors)) {
				for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) {
					processor.postProcessBeforeDestruction(this.bean, this.beanName);
				}
			}
			if (this.invokeDisposableBean) ((DisposableBean) bean).destroy();
			if (this.destroyMethod != null) {
				invokeCustomDestroyMethod(this.destroyMethod);
			}else if (this.destroyMethodName != null) {
				Method methodToCall = determineDestroyMethod();
				if (methodToCall != null) invokeCustomDestroyMethod(methodToCall);
			}
		}
	}
	populateBean(beanName, mbd, instanceWrapper){
		PropertyValues pvs = mbd.getPropertyValues();

		if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) { // important!!!
			apply InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation
		}

		if (RootBeanDefinition.AUTOWIRE_BY_NAME || RootBeanDefinition.AUTOWIRE_BY_TYPE) {
			//MutablePropertyValues implements PropertyValues
			//MutablePropertyValues.addPropertyValue will replace the original PropertyValue or merge it
			//pvs itself is MutablePropertyValues
			MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
			// Add property values based on autowire by name if applicable.
			if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
				autowireByName(beanName, mbd, bw, newPvs);{
					unsatisfiedNonSimpleProperties{
						PropertyValues pvs = mbd.getPropertyValues();
						PropertyDescriptor[] pds = bw.getPropertyDescriptors();
						for (PropertyDescriptor pd : pds) {
							//autowire candidate conditions:
							//has writer, no dep check, not contained in PropertyValues, not simple type
							if (pd.getWriteMethod() != null && !isExcludedFromDependencyCheck(pd) && !pvs.contains(pd.getName()) &&
									!BeanUtils.isSimpleProperty(pd.getPropertyType())) {
								result.add(pd.getName());
							}
						}
					}
				}
			}
			// Add property values based on autowire by type if applicable.
			if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
				autowireByType(beanName, mbd, bw, newPvs);{
					unsatisfiedNonSimpleProperties{}
					resolveDependency{}
				}
			}
			pvs = newPvs;
		}
		
		if (hasInstAwareBpps) { // important!!!
			apply InstantiationAwareBeanPostProcessor.postProcessPropertyValues // AutowiredAnnotationBeanPostProcessor
		}
		if (needsDepCheck) {
			checkDependencies(beanName, mbd, filteredPds, pvs);
		}
		
		applyPropertyValues(beanName, mbd, bw, pvs);{
			if (pvs == null || pvs.isEmpty()) {
				return;
			}
			
			if (pvs instanceof MutablePropertyValues) {
				List<PropertyValue> original = mpvs.getPropertyValueList();
			} else {
				List<PropertyValue> original = Arrays.asList(pvs.getPropertyValues());
			}
			List<PropertyValue> deepCopy = new ArrayList<PropertyValue>(original.size());
			for (PropertyValue pv : original) {
				Object originalValue = pv.getValue();
				//resolveValueIfNecessary will deal with array,list,set,map,property and so on
				Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);{
					//do not mind this part any more
					//VALUE_TYPE_ATTRIBUTE will define the element_type of ManagedXXXX, see parseXXXXElement of BeanDefinitionParserDelegate
					//resolveManagedArray will return element_type array while the other resolveManagedXXXX will return Object_type container
					//evaluate function can resolve Spell expression
				}
				Object convertedValue = resolvedValue;
				boolean convertible = bw.isWritableProperty(propertyName) &&
						!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
				if convertible
					//call typeConverter to convert the value
					convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
				//avoid re-conversion
				if (resolvedValue == originalValue) {
					if (convertible) {
						pv.setConvertedValue(convertedValue);
					}
					deepCopy.add(pv);
				}
				else if (convertible && originalValue instanceof TypedStringValue &&
						!((TypedStringValue) originalValue).isDynamic() &&
						!(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
					pv.setConvertedValue(convertedValue);
					deepCopy.add(pv);
				}
				else {
					resolveNecessary = true;
					deepCopy.add(new PropertyValue(pv, convertedValue));
				}
			}
			if (mpvs != null && !resolveNecessary) {
				mpvs.setConverted();
			}
			bw.setPropertyValues(new MutablePropertyValues(deepCopy)){
				for (PropertyValue pv : propertyValues) {
					setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv)(BeanWrapperImpl){
						//keys are abc,bcd from property name of props['abc']['bcd']
						if (tokens.keys != null) {
							...???
						}else{
							//no writable method found, NotWritablePropertyException!!!
							//PropertyMatches class to find the possible property!!!
							get the PropertyDescriptor to get the WriteMethod{
								getWriteMethod(){
									writeMethodName = Introspector.SET_PREFIX + getBaseName();//NameGenerator.capitalize(getName()); make the initial character capital
									writeMethod = Introspector.findMethod(cls, writeMethodName, 1, args);
								}
							}
							if (pv.isConverted()) {
								valueToApply = pv.getConvertedValue();
							} else {
								get the oldValue from readMethod 
								valueToApply = convertForProperty(propertyName, oldValue, originalValue, pd,...);
							}
							get the writeMethod and invoke with valueToApply
						}
					}
				}
			}
		}
	}
	initializeBean(beanName, exposedObject, mbd){
		invokeAwareMethods
		applyBeanPostProcessorsBeforeInitialization
		invokeInitMethods{
			afterPropertiesSet(InitializingBean)
			invokeCustomInitMethod
		}
		applyBeanPostProcessorsAfterInitialization  //may be wrapIfNecessary to create proxy (AbstractAutoProxyCreator)
	}
	//if require type is int, it will return Integer
	//value is always String, parsed by beanDefinitionParser or AutowiredAnnotationBeanPostProcessor
	//convertIfNecessary has three format
	TypeConverterSupport.convertIfNecessary(){
		doConvert(Object value, Class<T> requiredType, MethodParameter methodParam, Field field){
			if field is not null
			return this.typeConverterDelegate.convertIfNecessary(value, requiredType, field){
				return convertIfNecessary(null, null, value, requiredType,
				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)));{
					//convertedValue is the value to be converted
					PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);
					ConversionFailedException firstAttemptEx = null;
					ConversionService conversionService = this.propertyEditorRegistry.getConversionService();
					// No custom editor but custom ConversionService specified
					if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null){
						return (T) conversionService.convert
					}
					
					//Value not of required type or has editor
					if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue)) ){
						if requiredType is Collection and convertedValue is String
							turn convertedValue into String array
						if (editor == null) {
							editor = findDefaultEditor(requiredType);{
								if (requiredType != null) {
									// No custom editor -> check BeanWrapperImpl's default editors.
									editor = this.propertyEditorRegistry.getDefaultEditor(requiredType);//type mapped to editor
									if (editor == null && !String.class.equals(requiredType)) {
										// No BeanWrapper default editor -> check standard JavaBean editor.
										editor = BeanUtils.findEditorByConvention(requiredType);{
											String editorName = targetType.getName() + "Editor";
											Class<?> editorClass = cl.loadClass(editorName);
											if (!PropertyEditor.class.isAssignableFrom(editorClass)) {
												unknownEditorTypes.put(targetType, Boolean.TRUE);
												return null;
											}
											return (PropertyEditor) instantiateClass(editorClass);
										}
									}
								}
							}
						}
						convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor){
							
							deal with situation convertedValue is not a String(no return statement)
							
							if convertedValue instanceof String{
								if (editor != null) {
									String newTextValue = (String) convertedValue;
									return doConvertTextValue(oldValue, newTextValue, editor);{
										editor.setValue(oldValue);
										editor.setAsText(newTextValue);
										return editor.getValue();
									}
								}
								else if (String.class.equals(requiredType)) {
									returnValue = convertedValue;
								}
							}
							return returnValue;							
						}
					}
					//always skipp the following rules
					if (requiredType != null) {
						// Try to apply some standard type conversion rules if appropriate.
						if (convertedValue != null) {
							if (Object.class.equals(requiredType)) {
								return (T) convertedValue;
							}
							if (requiredType.isArray()) {
								convertToTypedArray {
									get componentType, no need to call getElementTypeDescriptor
								}
							}else if (convertedValue instanceof Collection) {
								convertToTypedCollection  {
									TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor();{
										ResolvableType.getGenerics();
									}
									Iterator<?> it = original.iterator();
									for (; it.hasNext(); i++) {
										String indexedPropertyName = buildIndexedPropertyName(propertyName, i);
										Object convertedElement = convertIfNecessary(indexedPropertyName, null, element,
											(elementType != null ? elementType.getType() : null) , elementType);
									}
								}
							}else if (convertedValue instanceof Map) {
								convertToTypedMap {
									similar to convertToTypedCollection
								}
							}
							if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {
								convertedValue = Array.get(convertedValue, 0);
							}
							if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {
								// We can stringify any primitive value...
								return (T) convertedValue.toString();
							}
							else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {
								if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {
									Constructor<T> strCtor = requiredType.getConstructor(String.class);
									return BeanUtils.instantiateClass(strCtor, convertedValue);//why return string object ???
								}
								String trimmedValue = ((String) convertedValue).trim();
								if (requiredType.isEnum() && "".equals(trimmedValue)) {
									// It's an empty enum identifier: reset the enum value to null.
									return null;
								}
								convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);
							}
						}
					}
					return (T) convertedValue;
				}
			}else{
				return this.typeConverterDelegate.convertIfNecessary(value, requiredType, methodParam);
			}
		}
	}
---------------------createBean end----------------------------------
	
// Destroy start here.............

    public void contextDestroyed ( ServletContextEvent sce );
		closeWebApplicationContext(from ContextLoader){
			((ConfigurableWebApplicationContext) this.context).close(){
				doClose(){
					// Publish shutdown event.
					publishEvent(new ContextClosedEvent(this));
					
					// Stop all Lifecycle beans, to avoid delays during individual destruction.
					getLifecycleProcessor().onClose();
					
					// Destroy all cached singletons in the context's BeanFactory.
					destroyBeans();

					// Close the state of this context itself.
					closeBeanFactory();

					// Let subclasses do some final clean-up if they wish...
					onClose();
				}
				Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
			}
			...
		}

		
/** Resolver to use for checking if a bean definition is an autowire candidate */
private AutowireCandidateResolver autowireCandidateResolver = new SimpleAutowireCandidateResolver();

QualifierAnnotationAutowireCandidateResolver deal with Value and Qualifier, addQualifierType to add the other annotation type

resolveDependency is the important function for autowire

AutowiredAnnotationBeanPostProcessor extends SmartInstantiationAwareBeanPostProcessor/MergedBeanDefinitionPostProcessor (Value & Autowired)
	//used by autowireConstructor of AbstractAutowireCapableBeanFactory, autowireConstructor use ConstructorResolver to find the constructor
	determineCandidateConstructors(Class<?> beanClass, String beanName){
		//there must be one requiredConstructor and one defaultConstructor
		rawCandidates = beanClass.getDeclaredConstructors();
		List<Constructor<?>> candidates = new ArrayList<Constructor<?>>(rawCandidates.length);
		for (Constructor<?> candidate : rawCandidates) {
			AnnotationAttributes annotation = findAutowiredAnnotation(candidate){
				//autowiredAnnotationTypes has Autowired, Value.
				for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {
					AnnotationAttributes annotation = AnnotatedElementUtils.getAnnotationAttributes(candidate, type.getName());{
						AnnotationAttributes attributes = searchWithGetSemantics(element, annotationType, null, new MergedAnnotationAttributesProcessor());// ???
						AnnotationUtils.postProcessAnnotationAttributes(element, attributes, false, false); //dealwith @AliasFor & DefaultValueHolder
						return attributes;
					}
					if (annotation != null) return annotation;
				}
				return null;
			}
			if (ann == null) {
				Class<?> userClass = ClassUtils.getUserClass(beanClass);//get original class if current is cglib generated class
				if (userClass != beanClass) {
					Constructor<?> superCtor = userClass.getDeclaredConstructor(candidate.getParameterTypes());
					ann = findAutowiredAnnotation(superCtor);
				}
			}
			if (ann != null) {
				boolean required = determineRequiredStatus(ann);
				if (required) requiredConstructor = candidate;
				candidates.add(candidate);
			}else if (candidate.getParameterTypes().length == 0) {
				defaultConstructor = candidate;
			}
		}
		if (!candidates.isEmpty()) {
			// Add default constructor to list of optional constructors, as fallback.
			if (requiredConstructor == null) {
				if (defaultConstructor != null) {
					candidates.add(defaultConstructor);
				}
			}
			candidateConstructors = candidates.toArray(new Constructor<?>[candidates.size()]);
		}
		else if (rawCandidates.length == 1 && rawCandidates[0].getParameterTypes().length > 0) {
			candidateConstructors = new Constructor<?>[] {rawCandidates[0]};
		}
		else {
			candidateConstructors = new Constructor<?>[0];
		}
		this.candidateConstructorsCache.put(beanClass, candidateConstructors);
		return candidateConstructors;
	}
	
	postProcessMergedBeanDefinition{
		InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType){
			String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
			InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
			if metadata == null{
				metadata = buildAutowiringMetadata(clazz){
					do {
						for (Field field : targetClass.getDeclaredFields()) {
							AnnotationAttributes annotation = findAutowiredAnnotation(field);
							if (Modifier.isStatic(field.getModifiers()))
								continue;
							boolean required = determineRequiredStatus(annotation);
							currElements.add(new AutowiredFieldElement(field, required));
						}
						for (Method method : targetClass.getDeclaredMethods()) {
							return the original bridgedMethod of bridge method or current method if current not bridge method
							Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
							if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {//'visibility' bridge method
								continue;
							}
							AnnotationAttributes annotation = findAutowiredAnnotation(bridgedMethod);
							if (annotation != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {
								if (Modifier.isStatic(method.getModifiers()))
									continue;
								boolean required = determineRequiredStatus(annotation);
								PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod){
									PropertyDescriptor[] pds = getPropertyDescriptors(method.getDeclaringClass());
									for (PropertyDescriptor pd : pds) {
										if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {
											return pd;
										}
									}
									return null;
								}
								currElements.add(new AutowiredMethodElement(method, required, pd));
							}
						}
						elements.addAll(0, currElements);
						targetClass = targetClass.getSuperclass();
					}while (targetClass != null && targetClass != Object.class);
					return new InjectionMetadata(clazz, elements);
				}
				this.injectionMetadataCache.put(cacheKey, metadata);
			}
		}
		//checkedElements will be injected later
		metadata.checkConfigMembers(beanDefinition);{
			for (InjectedElement element : this.injectedElements) {
				Member member = element.getMember();
				if (!beanDefinition.isExternallyManagedConfigMember(member)) {
					beanDefinition.registerExternallyManagedConfigMember(member);
					checkedElements.add(element);
				}
			}
			this.checkedElements = checkedElements;	
		}
	}
	
	postProcessPropertyValues{
		InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass());
		metadata.inject(bean, beanName, pvs){
			Collection<InjectedElement> elementsToIterate = (this.checkedElements != null ? this.checkedElements : this.injectedElements);
			for (InjectedElement element : elementsToIterate) {
				element.inject(bean, beanName, pvs){
				AutowiredFieldElement{
					if (this.cached) {
						value = resolvedCachedArgument(beanName, this.cachedFieldValue){
							if (cachedArgument instanceof DependencyDescriptor) {
								DependencyDescriptor descriptor = (DependencyDescriptor) cachedArgument;
								return this.beanFactory.resolveDependency(descriptor, beanName, null, null);
							}else if (cachedArgument instanceof RuntimeBeanReference) {
								return this.beanFactory.getBean(((RuntimeBeanReference) cachedArgument).getBeanName());
							}else {
								return cachedArgument;
							}
						}
					}else {
						DependencyDescriptor desc = new DependencyDescriptor(field, this.required);
						desc.setContainingClass(bean.getClass());
						//value can be bean, primitive value, DependencyObjectFactory and DependencyProvider
						value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
						//setup cachedFieldValue
						if (!this.cached) {
							if (value != null || this.required) {
								this.cachedFieldValue = desc;
								registerDependentBeans(beanName, autowiredBeanNames);//Register the specified beanName as dependent(依赖他人者)
								if (autowiredBeanNames.size() == 1) {
									String autowiredBeanName = autowiredBeanNames.iterator().next();
									if (beanFactory.containsBean(autowiredBeanName)) {
										if (beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {
											this.cachedFieldValue = new ShortcutDependencyDescriptor(
													desc, autowiredBeanName, field.getType());
										}
									}
								}
							}else {
								this.cachedFieldValue = null;
							}
							this.cached = true;
						}
					}
					if (value != null) {
						ReflectionUtils.makeAccessible(field);
						field.set(bean, value);
					}
				}
				AutowiredMethodElement{
					//the same as AutowiredFieldElement
					if (checkPropertySkipping(pvs)) return;
					Method method = (Method) this.member;
					if (this.cached) {
						arguments = resolveCachedArguments(beanName);//call resolvedCachedArgument
					}else{
						...
						for (int i = 0; i < arguments.length; i++) { // all parameters will be resolved even if no annotation on it
							MethodParameter methodParam = new MethodParameter(method, i);
							DependencyDescriptor desc = new DependencyDescriptor(methodParam, this.required);
							descriptors[i] = desc;
							Object arg = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
							arguments[i] = arg;
						}
						...
						setup this.cachedMethodArguments
					}
					if (arguments != null) {
						ReflectionUtils.makeAccessible(method);
						method.invoke(bean, arguments);
					}
				}
				}
			}
		}
	}
	DefaultListableBeanFactory.resolveDependency(DependencyDescriptor descriptor, String beanName, Set<String> autowiredBeanNames, TypeConverter typeConverter){
		deal with other descriptor.getDependencyType()
		else{
			Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, beanName){
				if isLazy(descriptor){
					ContextAnnotationAutowireCandidateResolver.buildLazyResolutionProxy{
						TargetSource ts = new TargetSource() {
								... (ignore)
								public Object getTarget() {
									return beanFactory.doResolveDependency(descriptor, beanName, null, null);
								}
						}
						ProxyFactory pf = new ProxyFactory();
						pf.setTargetSource(ts);
						Class<?> dependencyType = descriptor.getDependencyType();
						if (dependencyType.isInterface()) {
							pf.addInterface(dependencyType);
						}
						return pf.getProxy(beanFactory.getBeanClassLoader());
					}
				}
			}
			if result == null then
			return doResolveDependency(descriptor, beanName, autowiredBeanNames, typeConverter){
				Class<?> type = descriptor.getDependencyType();
				Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);// get value of @Value
				if value not null{
					if value is String{
						String strVal = resolveEmbeddedValue((String) value);{
							for (StringValueResolver resolver : this.embeddedValueResolvers) {
								//PlaceholderResolvingStringValueResolver to resolve the placeholder
								result = resolver.resolveStringValue(result);
							}
							return result;
						}
						BeanDefinition bd = (beanName != null && containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);
						value = evaluateBeanDefinitionString(strVal, bd)(AbstractBeanFactory){
							//call expression resolver to resolve the value to expression
							return evaluate(StandardBeanExpressionResolver){
								//SpelExpressionParser
								expr = this.expressionParser.parseExpression(value, this.beanExpressionParserContext);{
									if (context.isTemplate()) {
										//always go this way
										return parseTemplate(expressionString, context);
									}else {
										return doParseExpression(expressionString, context);
									}
								}
								this.expressionCache.put(value, expr);
								//several PropertyAccessor to get value from different source, BeanFactoryAccessor to get bean from the beanfactory
								setup the StandardEvaluationContext and put it into evaluationCache
								return expr.getValue(sec){
									too complex ???
									//CompoundExpression with PropertyOrFieldReference and Indexer for list,map,property: props['abc']
									//CompoundExpression with PropertyOrFieldReference and MethodReference for function calling: config.getTheTestIfExist('test')
								}
							}
						}
					}
					TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
					return converter.convertIfNecessary(value, type, descriptor.getField());
				}
				Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter){
					Class<?> type = descriptor.getDependencyType();
					if (type.isArray()) {
						to get componentType of type
						Map<String, Object> matchingBeans = findAutowireCandidates(beanName, componentType, new MultiElementDescriptor(descriptor));
						if (autowiredBeanNames != null) {
							autowiredBeanNames.addAll(matchingBeans.keySet());
						}
						TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
						Object result = converter.convertIfNecessary(matchingBeans.values(), type);
						if (this.dependencyComparator != null && result instanceof Object[]) {
							Arrays.sort((Object[]) result, this.dependencyComparator);
						}
						return result;
					}else if (Collection.class.isAssignableFrom(type) && type.isInterface()) {
						to get elementType of type
						Map<String, Object> matchingBeans = findAutowireCandidates(beanName, elementType, new MultiElementDescriptor(descriptor));
						if (autowiredBeanNames != null) {
							autowiredBeanNames.addAll(matchingBeans.keySet());
						}
						TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
						Object result = converter.convertIfNecessary(matchingBeans.values(), type);
						if (this.dependencyComparator != null && result instanceof List) {
							Collections.sort((List<?>) result, this.dependencyComparator);
						}
						return result;
					}else  if (Map.class.isAssignableFrom(type) && type.isInterface()) {
						to get keyType of type as map
						if (keyType == null || !String.class.isAssignableFrom(keyType)) {
							return null;
						}
						to get valueType of type as map
						Map<String, Object> matchingBeans = findAutowireCandidates(beanName, valueType, new MultiElementDescriptor(descriptor));
						if (autowiredBeanNames != null) {
							autowiredBeanNames.addAll(matchingBeans.keySet());
						}
						return matchingBeans;
					}else {
						return null;
					}
				}
				if (multipleBeans != null) {
					return multipleBeans;
				}
				Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
				if (matchingBeans.isEmpty()) {
					if (descriptor.isRequired()) {
						raiseNoSuchBeanDefinitionException(type, "", descriptor);
					}
					return null; // default is null
				}
				if (matchingBeans.size() > 1) {
					autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);{
						determinePrimaryCandidate // @Primary
						determineHighestPriorityCandidate //@Priority
						this.resolvableDependencies.containsValue(beanInstance) || matchesBeanName(candidateName, descriptor.getDependencyName())
					}
					if (autowiredBeanName == null) {
						if (isRequired(descriptor) || !indicatesMultipleBeans(type)) { // indicates type is array or collection or map 
							throw exception
						} else {
							return null; // MultipleBeans can be null
						}
					}
					instanceCandidate = matchingBeans.get(autowiredBeanName);
				}else{
					// We have exactly one match.
					Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
					autowiredBeanName = entry.getKey();
					instanceCandidate = entry.getValue();
				}
				if (autowiredBeanNames != null) {
					autowiredBeanNames.add(autowiredBeanName);
				}
				return (instanceCandidate instanceof Class ?
						descriptor.resolveCandidate(autowiredBeanName, type, this) : instanceCandidate);
			}
		}
	}
	
	DefaultListableBeanFactory.findAutowireCandidates(String beanName, Class<?> requiredType, DependencyDescriptor descriptor){
		String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors
		
		//resolvableDependencies contains BeanFactory.class, ResourceLoader.class, ApplicationEventPublisher.class, ApplicationContext.class and so on
		for (Class<?> autowiringType : this.resolvableDependencies.keySet()) {
			if (autowiringType.isAssignableFrom(requiredType)) {
				Object autowiringValue = this.resolvableDependencies.get(autowiringType);
				autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);//resolve ObjectFactory value to its actual object result
				if (requiredType.isInstance(autowiringValue)) {
					result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);
					break;
				}
			}
		}
		for (String candidateName : candidateNames) {
			//isAutowireCandidate will call AutowireCandidateResolver.isAutowireCandidate and then call AutowireCandidateResolver.checkQualifiers to deal with Qualifier.
			if (!isSelfReference(beanName,candidateName) && isAutowireCandidate(candidateName, descriptor)) {
				addCandidateEntry(result, candidateName, descriptor, requiredType);{
					if (descriptor instanceof MultiElementDescriptor || containsSingleton(candidateName)) {
						result.put(candidateName, descriptor.resolveCandidate(candidateName, requiredType, this));
					}else {
						result.put(candidateName, getType(candidateName));
					}
				}
			}
		}
		//For a fallback match
		if (result.isEmpty() && !indicatesMultipleBeans(requiredType)) {
			DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();// fallbackMatchAllowed return true
			for (String candidateName : candidateNames) {
				if (!isSelfReference(beanName,candidateName) && isAutowireCandidate(candidateName, fallbackDescriptor)) {
					addCandidateEntry(result, candidateName, descriptor, requiredType);
				}
			}
			...
		}
		return result;
	}
	
	DefaultListableBeanFactory.isAutowireCandidate(String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver){
		if (containsBeanDefinition(beanDefinitionName)) {
			return isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanDefinitionName), descriptor, resolver);
			{
				resolveBeanClass(mbd, beanDefinitionName);
				if (mbd.isFactoryMethodUnique) {//for @Bean not static method
					if (mbd.resolvedConstructorOrFactoryMethod == null) {
						new ConstructorResolver(this).resolveFactoryMethodIfPossible(mbd);{//try to resolve FactoryMethod
							too complex ???
						}
					}
				}
				return resolver.isAutowireCandidate(new BeanDefinitionHolder(mbd, beanName, getAliases(beanDefinitionName)), descriptor);{
					boolean match = super.isAutowireCandidate(bdHolder, descriptor){
						//private boolean autowireCandidate = true; component scanner can setup autowireCandidatePatterns to reset autowireCandidate
						if (!bdHolder.getBeanDefinition().isAutowireCandidate()) {
							return false;
						}
						//if No generic type, it will return true
						return (descriptor == null || checkGenericTypeMatch(bdHolder, descriptor));
					}
					if (match && descriptor != null) {
						//descriptor.getAnnotations() returns field's annotations or methodParameter's annotations
						//getParameterAnnotations of reflect
						match = checkQualifiers(bdHolder, descriptor.getAnnotations());
						if (match) {
							MethodParameter methodParam = descriptor.getMethodParameter();
							//Why we do this (Qualifier can be used on method and parameters)
							if (methodParam != null) {
								Method method = methodParam.getMethod();
								//Constructor parameters or void method
								if (method == null || void.class.equals(method.getReturnType())) {
									//methodParam.getMethodAnnotations() returns all annotations of method/constructor
									//getAnnotations of reflect
									match = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());
								}
							}
						}
					}
					return match;
				}
			}
		}
		else if (containsSingleton(beanName)) {
			//the same function as above
			return isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver);
		}
		else if (getParentBeanFactory() instanceof DefaultListableBeanFactory) {
			// No bean definition found in this factory -> delegate to parent.
			return ((DefaultListableBeanFactory) getParentBeanFactory()).isAutowireCandidate(beanName, descriptor, resolver);
		}
		else if (getParentBeanFactory() instanceof ConfigurableListableBeanFactory) {
			// If no DefaultListableBeanFactory, can't pass the resolver along.
			return ((ConfigurableListableBeanFactory) getParentBeanFactory()).isAutowireCandidate(beanName, descriptor);
		}
		else {
			return true;
		}
	}
	
	checkQualifiers(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch){
		for (Annotation annotation : annotationsToSearch) {
			Class<? extends Annotation> type = annotation.annotationType();
			boolean checkMeta = true; //check annotation type's annotation
			boolean fallbackToMeta = false; //accept fallback match
			if type in this.qualifierTypes {
				if (!checkQualifier(bdHolder, annotation, typeConverter)) {
					fallbackToMeta = true;
				}
				else {
					checkMeta = false;
				}
			}
			if (checkMeta) {
				for (Annotation metaAnn : type.getAnnotations()) {
					Class<? extends Annotation> metaType = metaAnn.annotationType();
					if metaType in this.qualifierTypes {
						foundMeta = true;
						// Only accept fallback match if @Qualifier annotation has a value
						// and then check qualifier match
						if ((fallbackToMeta && StringUtils.isEmpty(AnnotationUtils.getValue(metaAnn))) ||
								!checkQualifier(bdHolder, metaAnn, typeConverter)) {
							return false;
						}
					}
				}
				if (fallbackToMeta && !foundMeta) {
					return false;
				}
			}
		}
		return true;
	}
	QualifierAnnotationAutowireCandidateResolver.checkQualifier(BeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter){
		Class<? extends Annotation> type = annotation.annotationType();
		//<qualifier> within <Bean> will register qualifier to bd
		AutowireCandidateQualifier qualifier = bd.getQualifier(type.getName());
		if (qualifier == null) {
			qualifier = bd.getQualifier(ClassUtils.getShortName(type));
		}
		//bd has no <qualifier>
		if (qualifier == null) {
			Annotation targetAnnotation = getQualifiedElementAnnotation(bd, type);// check annotation on qualifiedElement ???
			if (targetAnnotation == null) {
				targetAnnotation = getFactoryMethodAnnotation(bd, type);// check annotation on factory method, @Qualifier with @Bean
			}
			if (targetAnnotation == null) {
				RootBeanDefinition dbd = getResolvedDecoratedDefinition(bd);// getMergedBeanDefinition(rbd.getDecoratedDefinition().getBeanName);
				if (dbd != null) {
					targetAnnotation = getFactoryMethodAnnotation(dbd, type);
				}
			}
			if (targetAnnotation == null) {
				// Look for matching annotation on the target class
				if (getBeanFactory() != null) {
					Class<?> beanType = getBeanFactory().getType(bdHolder.getBeanName());
					if (beanType != null) {
						targetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(beanType), type);
					}
				}
				if (targetAnnotation == null && bd.hasBeanClass()) {
					targetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(bd.getBeanClass()), type);
				}
			}
			//just use equals, much easier than the xml qualifier
			if (targetAnnotation != null && targetAnnotation.equals(annotation)) {
				return true;
			}
		}
		//use xml qualifier, much more trivial
		Map<String, Object> attributes = AnnotationUtils.getAnnotationAttributes(annotation);
		for (Map.Entry<String, Object> entry : attributes.entrySet()) {
			String attributeName = entry.getKey();
			Object expectedValue = entry.getValue();
			Object actualValue = null;
			if (qualifier != null) {
				actualValue = qualifier.getAttribute(attributeName);
			}
			if (actualValue == null) {// Fall back on bean definition attribute
				actualValue = bd.getAttribute(attributeName);
			}
			if (actualValue == null && attributeName.equals(AutowireCandidateQualifier.VALUE_KEY) &&
					expectedValue instanceof String && bdHolder.matchesName((String) expectedValue)) {// Fall back on bean name (or alias) match
				continue;
			}
			if (actualValue == null && qualifier != null) {// Fall back on default, but only if the qualifier is present
				actualValue = AnnotationUtils.getDefaultValue(annotation, attributeName);
			}
			if (actualValue != null) {
				actualValue = typeConverter.convertIfNecessary(actualValue, expectedValue.getClass());
			}
			if (!expectedValue.equals(actualValue)) {
				return false;
			}
		}
		return true;
	}
	
CommonAnnotationBeanPostProcessor extends InitDestroyAnnotationBeanPostProcessor/MergedBeanDefinitionPostProcessor (Resource & PostConstruct & PreDestroy)
CommonAnnotationBeanPostProcessor somehow the same as AutowiredAnnotationBeanPostProcessor
inject at postProcessPropertyValues
init at postProcessBeforeInitialization
destroy at postProcessBeforeDestruction

@Import(ImportSelector or ImportBeanDefinitionRegistrar or otherClass)
ImportAware.setImportMetadata(ImportRegistry.getImportingClassFor())
ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor: has ConfigurationClassParser and ConfigurationClassBeanDefinitionReader
	candidateIndicators.add(Component.class.getName());
	candidateIndicators.add(ComponentScan.class.getName());
	candidateIndicators.add(Import.class.getName());
	candidateIndicators.add(ImportResource.class.getName());
		
	postProcessBeanDefinitionRegistry{
		int registryId = System.identityHashCode(registry);
		registryId 判重
		processConfigBeanDefinitions(registry);
	}
	
	postProcessBeanFactory{
		int factoryId = System.identityHashCode(beanFactory);
		factoryId 判重
		if (!this.registriesPostProcessed.contains(factoryId))
			processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);
		enhanceConfigurationClasses(beanFactory);
		beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));
	}
	
	processConfigBeanDefinitions{
		String[] candidateNames = registry.getBeanDefinitionNames();
		for (String beanName : candidateNames) {
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || //  a class annotated with @Configuration
					ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) { // a class annotated with candidateIndicators or just having @Bean methods
				beanDef has Full/Lite attribute, do nothing !!!
			}else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {// set Full/Lite attribute to beanDef
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
			}
		}
		sort configCandidates
		
		Detect any custom bean name generation strategy // org.springframework.context.annotation.internalConfigurationBeanNameGenerator
		BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
		this.componentScanBeanNameGenerator = generator;
		this.importBeanNameGenerator = generator;
		
		ConfigurationClassParser parser = new ConfigurationClassParser(...);
		Set<BeanDefinitionHolder> candidates = new LinkedHashSet<BeanDefinitionHolder>(configCandidates);
		Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());
		do {
			// Read the model and create bean definitions based on its content
			parser.parse(candidates);
			parser.validate();
			Set<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());
			configClasses.removeAll(alreadyParsed);
			
			this.reader = ConfigurationClassBeanDefinitionReader(...);
			this.reader.loadBeanDefinitions(configClasses);
			alreadyParsed.addAll(configClasses);
			
			candidates.clear();
			retry to load candidates from registry as ConfigurationClassParser will introduce more ConfigurationClassCandidate
		}while (!candidates.isEmpty());

		// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
		if (singletonRegistry != null) {
			if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) { // ConfigurationClassPostProcessor.class.getName() + ".importRegistry"
				singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
			}
		}
	}
	ConfigurationClassParser.parse(Set<BeanDefinitionHolder> configCandidates){
		for (BeanDefinitionHolder holder : configCandidates) {
			BeanDefinition bd = holder.getBeanDefinition();
			parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());{
				processConfigurationClass(new ConfigurationClass(clazz, beanName));{
					if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) return;
					merge importedBy ???
					SourceClass sourceClass = asSourceClass(configClass);//wrap Class of configClass
					do {
						sourceClass = doProcessConfigurationClass(configClass, sourceClass);{
							processMemberClasses(configClass, sourceClass);

							// Process any @PropertySource annotations
							for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
									sourceClass.getMetadata(), PropertySources.class,
									org.springframework.context.annotation.PropertySource.class)) {
								if (this.environment instanceof ConfigurableEnvironment) {
									processPropertySource(propertySource);
								}
							}

							// Process any @ComponentScan annotations
							Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
									sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
							if (!componentScans.isEmpty() &&
									!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
								for (AnnotationAttributes componentScan : componentScans) {
									// The config class is annotated with @ComponentScan -> perform the scan immediately
									Set<BeanDefinitionHolder> scannedBeanDefinitions =
											this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
									for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
										if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {
											parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());
										}
									}
								}
							}

							// Process any @Import annotations
							processImports(configClass, sourceClass, getImports(sourceClass), true);//getImports -> get value of @Import

							// Process any @ImportResource annotations
							if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {
								AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
								String[] resources = importResource.getStringArray("locations");
								Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader");
								for (String resource : resources) {
									String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
									configClass.addImportedResource(resolvedResource, readerClass);
								}
							}

							// Process individual @Bean methods
							Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
							for (MethodMetadata methodMetadata : beanMethods) {
								configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
							}

							// Process default methods on interfaces
							processInterfaces(configClass, sourceClass);

							// Process superclass, if any
							if (sourceClass.getMetadata().hasSuperClass()) {
								String superclass = sourceClass.getMetadata().getSuperClassName();
								if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {
									this.knownSuperclasses.put(superclass, configClass);
									// Superclass found, return its annotation metadata and recurse
									return sourceClass.getSuperClass();
								}
							}

							// No superclass -> processing is complete
							return null;
						}
					}while (sourceClass != null);
					this.configurationClasses.put(configClass, configClass); //key and value the same ...
				}
			}
		}
		processDeferredImportSelectors();{
			List<DeferredImportSelectorHolder> deferredImports = this.deferredImportSelectors;
			this.deferredImportSelectors = null;
			Collections.sort(deferredImports, DEFERRED_IMPORT_COMPARATOR);
			for (DeferredImportSelectorHolder deferredImport : deferredImports) {
				ConfigurationClass configClass = deferredImport.getConfigurationClass();
				String[] imports = deferredImport.getImportSelector().selectImports(configClass.getMetadata());
				processImports(configClass, asSourceClass(configClass), asSourceClasses(imports), false);	
			}
		}
	}
	ConfigurationClassParser.processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass){
		for (SourceClass memberClass : sourceClass.getMemberClasses()) {
			// isConfigurationCandidate -> Full or Lite ConfigClass
			if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&
					!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {
				this.importStack.push(configClass);
				try {
					processConfigurationClass(memberClass.asConfigClass(configClass));
					//create ConfigurationClass with imported configClass, isImported is true
				}
				finally {
					this.importStack.pop();
				}
			}
		}
	}
	ConfigurationClassParser.processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
			Collection<SourceClass> importCandidates, boolean checkForCircularImports){
		if checkForCircularImports check circular imports with importStack
		else{
			this.importStack.push(configClass);//ArrayDeque push
			try {
				for (SourceClass candidate : importCandidates) {
					if (candidate.isAssignable(ImportSelector.class)) {
						// Candidate class is an ImportSelector -> delegate to it to determine imports
						Class<?> candidateClass = candidate.loadClass();
						ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
						ParserStrategyUtils.invokeAwareMethods(selector, this.environment, this.resourceLoader, this.registry);//set environment/resourceLoader/registry
						if (this.deferredImportSelectors != null && selector instanceof DeferredImportSelector) {
							this.deferredImportSelectors.add(new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));
						}else {
							String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
							Collection<SourceClass> importSourceClasses = asSourceClasses(importClassNames);
							processImports(configClass, currentSourceClass, importSourceClasses, false);
						}
					}else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
						// Candidate class is an ImportBeanDefinitionRegistrar -> delegate to it to register additional bean definitions
						Class<?> candidateClass = candidate.loadClass();
						ImportBeanDefinitionRegistrar registrar = BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
						ParserStrategyUtils.invokeAwareMethods(registrar, this.environment, this.resourceLoader, this.registry);
						configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
					}else {
						// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -> process it as an @Configuration class
						this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
						processConfigurationClass(candidate.asConfigClass(configClass));//create ConfigurationClass with importedConfigClass, isImported is true
					}
				}
			}finally {
				this.importStack.pop();//ArrayDeque pop
			}
		}
	}
	ImportStack extends ArrayDeque<ConfigurationClass> implements ImportRegistry{
		private final MultiValueMap<String, AnnotationMetadata> imports = new LinkedMultiValueMap<String, AnnotationMetadata>();
		public void registerImport(AnnotationMetadata importingClass, String importedClass) {
			this.imports.add(importedClass, importingClass);
		}
		public AnnotationMetadata getImportingClassFor(String importedClass) {
			List<AnnotationMetadata> list = this.imports.get(importedClass);
			return (!CollectionUtils.isEmpty(list) ? list.get(list.size() - 1) : null);
		}
		public void removeImportingClass(String importingClass) {
			for (List<AnnotationMetadata> list : this.imports.values()) {
				for (Iterator<AnnotationMetadata> iterator = list.iterator(); iterator.hasNext();) {
					if (iterator.next().getClassName().equals(importingClass)) {
						iterator.remove(); break;
					}
				}
			}
		}
	}
	private static class ImportAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter {
		private final BeanFactory beanFactory;
		public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) {
			if (bean instanceof EnhancedConfiguration) {
				((EnhancedConfiguration) bean).setBeanFactory(this.beanFactory);
			}
			return pvs;
		}
		public Object postProcessBeforeInitialization(Object bean, String beanName)  {
			if (bean instanceof ImportAware) {
				ImportRegistry ir = this.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);
				AnnotationMetadata importingClass = ir.getImportingClassFor(bean.getClass().getSuperclass().getName());
				if (importingClass != null) ((ImportAware) bean).setImportMetadata(importingClass);
			}
			return bean;
		}
	}
	ConfigurationClassBeanDefinitionReader.loadBeanDefinitions((Set<ConfigurationClass> configurationModel)){
		TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();//conditionEvaluator.shouldSkip
		for (ConfigurationClass configClass : configurationModel) {
			loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);{
				if (trackedConditionEvaluator.shouldSkip(configClass)) {
					String beanName = configClass.getBeanName();
					if (StringUtils.hasLength(beanName) && this.registry.containsBeanDefinition(beanName)) {
						this.registry.removeBeanDefinition(beanName);
					}
					this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName()); return;
				}
				if (configClass.isImported()) {
					registerBeanDefinitionForImportedConfigurationClass(configClass);{
						AnnotationMetadata metadata = configClass.getMetadata();
						AnnotatedGenericBeanDefinition configBeanDef = new AnnotatedGenericBeanDefinition(metadata);
						ScopeMetadata scopeMetadata = scopeMetadataResolver.resolveScopeMetadata(configBeanDef);
						configBeanDef.setScope(scopeMetadata.getScopeName());
						String configBeanName = this.importBeanNameGenerator.generateBeanName(configBeanDef, this.registry);
						AnnotationConfigUtils.processCommonDefinitionAnnotations(configBeanDef, metadata);
						BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(configBeanDef, configBeanName);
						definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
						this.registry.registerBeanDefinition(definitionHolder.getBeanName(), definitionHolder.getBeanDefinition());
						configClass.setBeanName(configBeanName);
					}
				}
				for (BeanMethod beanMethod : configClass.getBeanMethods()) {
					loadBeanDefinitionsForBeanMethod(beanMethod);{
						ConfigurationClass configClass = beanMethod.getConfigurationClass();
						MethodMetadata metadata = beanMethod.getMetadata();
						String methodName = metadata.getMethodName();

						if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {
							configClass.skippedBeanMethods.add(methodName); return;
						}
						if (configClass.skippedBeanMethods.contains(methodName)) return;
						for (String alias : names) { // @Bean(name="")
							this.registry.registerAlias(beanName, alias);
						}
						if (isOverriddenByExistingDefinition(beanMethod, beanName)) {//check bean clash, the same bean name
							return;
						}
						ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);
						beanDef.setResource(configClass.getResource());
						beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));
						if (metadata.isStatic()) {
							// static @Bean method
							beanDef.setBeanClassName(configClass.getMetadata().getClassName());
							beanDef.setFactoryMethodName(metadata.getMethodName());
						}else {
							// instance @Bean method
							beanDef.setFactoryBeanName(configClass.getBeanName());
							beanDef.setUniqueFactoryMethodName(metadata.getMethodName());
							//call setFactoryMethodName() and set isFactoryMethodUnique to true
						}
						beanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);
						AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);
						Autowire autowire = bean.getEnum("autowire");
						if (autowire.isAutowire()) {
							beanDef.setAutowireMode(autowire.value());
						}
						String initMethodName = bean.getString("initMethod");
						if (StringUtils.hasText(initMethodName)) {
							beanDef.setInitMethodName(initMethodName);
						}
						String destroyMethodName = bean.getString("destroyMethod");
						if (destroyMethodName != null) {
							beanDef.setDestroyMethodName(destroyMethodName);
						}
						ScopedProxyMode proxyMode = ScopedProxyMode.NO;
						AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);
						if (attributes != null) {
							beanDef.setScope(attributes.getString("value"));
							proxyMode = attributes.getEnum("proxyMode");
							if (proxyMode == ScopedProxyMode.DEFAULT) proxyMode = ScopedProxyMode.NO;
						}
						// Replace the original bean definition with the target one, if necessary
						BeanDefinition beanDefToRegister = beanDef;
						if (proxyMode != ScopedProxyMode.NO) {
							BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(
									new BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);
							beanDefToRegister = new ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);
						}
						this.registry.registerBeanDefinition(beanName, beanDefToRegister);
					}
				}
				loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); // XmlBeanDefinitionReader.loadBeanDefinitions
				loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());{
					for (Map.Entry<ImportBeanDefinitionRegistrar, AnnotationMetadata> entry : registrars.entrySet()) {
						entry.getKey().registerBeanDefinitions(entry.getValue(), this.registry);
					}
				}
			}
		}
	}
	
	enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory){
		Map<String, AbstractBeanDefinition> configBeanDefs = new LinkedHashMap<String, AbstractBeanDefinition>();
		for (String beanName : beanFactory.getBeanDefinitionNames()) {
			BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
			if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {
				configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);
			}
		}
		//enhancedClass has no annotations on the overrided methods which are declared within itself !!!
		ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); // objenesis is used
		for (Map.Entry<String, AbstractBeanDefinition> entry : configBeanDefs.entrySet()) {
			AbstractBeanDefinition beanDef = entry.getValue();
			// If a @Configuration class gets proxied, always proxy the target class
			beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
			// Set enhanced subclass of the user-specified bean class
			Class<?> configClass = beanDef.resolveBeanClass(this.beanClassLoader);
			Class<?> enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);
			if (configClass != enhancedClass) {
				beanDef.setBeanClass(enhancedClass);
			}
		}
	}
ConfigurationClassEnhancer{
	public interface EnhancedConfiguration extends BeanFactoryAware {//empty body
	}
	public Class<?> enhance(Class<?> configClass, ClassLoader classLoader){
		if (EnhancedConfiguration.class.isAssignableFrom(configClass)) {
			return configClass;
		}
		Class<?> enhancedClass = createClass(newEnhancer(configClass, classLoader){
			Enhancer enhancer = new Enhancer();
			enhancer.setSuperclass(configClass);
			enhancer.setInterfaces(new Class<?>[] {EnhancedConfiguration.class});
			enhancer.setUseFactory(false);
			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
			enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));//generate public BeanFactory field
			enhancer.setCallbackFilter(CALLBACK_FILTER);
			enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());
			return enhancer;
		});{
			Class<?> subclass = enhancer.createClass();
			Enhancer.registerStaticCallbacks(subclass, CALLBACKS);
			return subclass;
		}
		return enhancedClass;		
	}
	private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);
	private static final Callback[] CALLBACKS = new Callback[] {
			new BeanMethodInterceptor(),
			new BeanFactoryAwareMethodInterceptor(),//setBeanFactory
			NoOp.INSTANCE
	};
	private static class BeanMethodInterceptor implements MethodInterceptor, ConditionalCallback {
		... ???
	}
}

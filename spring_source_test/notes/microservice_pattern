逃离单体应用:
单体架构的好处和问题: (省略)
系统的三轴扩展立方体:
X轴水平扩展(负载均衡)；Z轴数据分区扩展(路由器): 提升系统吞吐量和可用性
Y轴垂直扩展(功能性分解): 解决日益增长的开发问题和应用复杂性
微服务是模块化的一种形式: 模块化的形式可以是: jar包(单体应用); 服务(微服务应用)
SOA架构和微服务的异同: 服务间通信，数据存储，服务规模大小
微服务的优点和弊端: (省略)
架构设计的核心是决策，当进行决策时会存在大量的权衡和取舍
微服务架构模式和模式语言: ??? 模式语言是由关系(前导，后续，泛化，特化，替换)相关的模式集合所形成，描述了与模式相关的问题域(模式语言包含多种模式)
服务拆分的相关模式，服务通信的相关模式，数据一致性的相关模式 ... (省略)

服务拆分策略:
软件架构的定义: 软件架构是构建这个系统所需要的一组结构，包括软件元素以及元素之间额关系
软件架构4+1视图模型:
逻辑视图:
        元素: 类和包
        关系: 它们之间的(UML)关系
实现视图:
        元素: jar包或者war包
        关系: 它们之间的依赖和组合关系
进程视图:
        元素: 进程
        关系: 进程间的通信
部署视图:
        元素: 机器和进程
        关系: 机器之间的网络结构
场景: 把视图中的元素如何协作串联在一起
应用程序有两个层面的需求，分为功能性需求(和架构没有任何关系)和非功能性需求(决定了可维护性，可测性，可扩展性和可部署性等)，架构的重要性在于帮助应用程序满足非功能性需求

架构风格(架构风格确定了该架构实例可以使用的组件(元素)和连接器(关系)的词汇表，以及如何组合它们的一组约束，应用程序的视图模型通常使用多种架构风格的组合)
分层(三层)架构，六边形架构
单体架构，微服务架构都是架构风格
微服务架构将应用程序构建为松耦合、可独立部署的一组服务 -> 什么是服务？(单一的、可独立部署的软件组件) 什么是松耦合？(服务间通过API交互，封装了实现细节，互不影响)

分布式单体应用 非常可怕!!!

如何为程序定义微服务架构:
1. 定义软件系统操作(从功能性需求也就是用户故事出发): 抽象的领域模型和系统操作能够明确应用的边界
1.1 创建由关键类组成的抽象领域模型(事件风暴)，对应用户故事中的名词
1.2 确定系统操作，根据领域模型描述每个操作的行为：
  系统操作分为命令型和查询型，对应用户故事中的动词
  命令规范定义了命令对应的参数，返回值和领域模型的行为，同时包括前置条件和后置动作

2. 定义服务：
2.1 根据业务能力进行服务拆分，起源于业务的架构
2.2 根据领域驱动设计的子域进行服务拆分: 通过子域和界限上下文映射为对应的领域服务
拆分原则: 1. 单一职责原则SRP 2. 共同闭包原则CCP
拆分难点: 1. 网络延时 2. 同步服务调用导致可用性降低 3. 服务间数据一致性 4. 跨多个数据库的一致性数据视图 5. 上帝类阻碍拆分(把上帝类的字段分组迁移到对应的领域)
3. 定义服务API和协作方式：把系统操作分配给对应的服务，确定服务与服务之间的协作通信方式

微服务架构中的进程间通信:
同步: 远程调用，服务调用相关的所有知识点(省略)
异步: 消息通信，消息相关的所有知识点(省略)

使用消息进行异步请求/响应: 通过"回复消息通道"进行响应回传 (没有具体落地细则) ???
使用异步消息提高可用性 (没有具体落地细则) ???

使用saga管理事务:
分布式事务的挑战: 分布式事务采用XA标准，XA采用了两阶段提交来保证事务中的所有参与方同时提交和回滚: 不是所有的中间件都遵守XA标准; 本质是同步进程间通信，降低分布式系统的可用性
saga模式: 通过使用异步消息来协调一系列本地事务，从而维护多个服务之间的数据一致性
saga使用补偿事务(逆向接口)来回滚所做出的改变
saga的协调模式:
协同式: 把saga的决策和执行顺序逻辑分布在saga的每一个参与方中，它们通过交换事件的方式来进行沟通
编排式: 吧saga的决策和执行顺序逻辑集中在一个saga编排器类中。saga编排器发出命令消息给各个saga参与方，指示参与方服务完成本地事务
协同式saga的好处和弊端(省略)
编排式saga的好处和弊端(省略)
解决隔离问题: saga只满足acd三个属性，缺乏隔离i
缺乏隔离会导致: 丢失更新；脏读；模糊或不可重复读；
saga模式下实现隔离的对策:
语义锁；应用程序级别的锁，通过pending状态来实现语义锁定，它告诉其他试图访问的服务当前数据正在处于saga处理过程中 (通常使用此对策)
交换式更新；
悲观视图；
重读值；
版本文件；
业务风险评级


微服务架构中的业务逻辑设计:
聚合可以起到以下两个重要的作用:
使用聚合可以避免任何跨服务边界的对象引用，因为聚合之间是通过主键进行引用而不是对象的地址
单个事务只能创建或更新单个聚合，因此聚合满足微服务事务模型的约束

组织业务逻辑有两种主要模式: 面向过程的事务脚本模式和面向对象的领域建模模式 143
事务脚本: 将业务逻辑组织为面向过程的事务脚本的集合，每种类型的请求对应一个脚本，这种模式通常把类分为实现行为的类和存储数据的类
事务脚本模式适用于简单的业务逻辑，无须考虑如何设计和组织各种类

领域模型: 将业务逻辑组织为具有状态和行为的类构成的对象模型
使用面向对象的好处: 大类拆分为小类，职责唯一，易于理解和维护；更容易进行测试；更容易扩展
面向对象的领域建模模式看似完美，同样存在多种问题，需要使用领域驱动设计的思路来优化面向对象设计

使用聚合模式设计领域模型
模糊边界带来的问题：在直接更新业务对象的一部分时可能会违反业务规则，例如order具有最小金额，直接更新order的项目时可能违反这个规则
聚合拥有明确的边界，是一个边界内的领域对象的集群，可以将其视为一个单元，聚合由根实体和一个或多个其他实体和值对象构成
聚合模式: 将领域模型组织为聚合的集合，每个聚合都可以作为一个单元进行处理的一组对象构成的图
聚合代表了一致的边界，它们阐明了加载、更新和删除等操作的范围，这些操作作用于整个聚合而不是聚合的部分，识别聚合的边界和根才是领域驱动设计的关键，而不是聚合内部的结构细节

领域驱动设计要求聚合遵守的规则:(这些规则确保聚合是一个可以强制执行各种业务规则的自包含单元)
1. 只引用聚合根
2. 聚合间的引用必须使用主键(传统的面向对象是直接对象引用)
3. 在一个事务中只能创建或更新一个聚合(使用saga进行多事务协作)

聚合的颗粒度: 在领域模型设计时关键的决策是决定聚合的大小：
一方面，聚合的大小影响数据的序列化性能，避免同时更新产生的竞争
另一方面聚合是事务的范围，可能需要定义更大的聚合来满足更新操作的原子性

领域事件是聚合发生的事情，聚合在被创建或发生其他重大变更时发布领域事件
领域事件类的定义: 普通型/增强型 (事件超类定义部分元数据)
领域事件的识别: 从需求描述中识别 / 利用事件风暴识别
生成和发布领域事件，消费领域事件等的实现介绍
kitchen service/order service实例介绍

使用事件溯源开发业务逻辑(省略)
使用传统的持久化方法实现业务逻辑，业务逻辑和事件的发布代码交织在一起:
缺乏聚合的历史
实施审计功能将非常繁琐
事件发布凌驾于业务逻辑之上

事件溯源的优点/缺点(省略)

在微服务架构中实现查询
API组合模式：让拥有数据的服务的客户端负责调用服务，并组合服务返回的查询结果
CQRS模式：维护有一个或多个视图数据库，其唯一目的是支持查询

API组合模式的两种类型的参与者:
API组合器：通过查询数据提供方服务来实现查询操作
数据提供方服务：拥有查询返回的部分数据的服务
API组合模式的缺陷:
确定架构中的哪个组件担当API组合器: 1. 客户端 2. API网关 3. 专门的查询服务
编写高效的聚合逻辑：使用响应式编程模型
API组合模式的缺点: 1. 增加额外开销 2. 带来可用性降低的风险 3. 缺乏事务数据一致性

CQRS模式：命令查询职责隔离，使用事件来维护从多个服务复制数据的只读视图
为什么使用CQRS：API组合模式无法满足分页，复杂过滤条件等场景的查询
1. 拥有数据的服务不适合实现各种查询 2. 服务使用的数据库不能有效支持查询 3. 使用API组合模式将数据在低效、昂贵的内存中连接
CQRS的好处 (省略)
CQRS的弊端 1. 更加复杂的架构 2. 处理数据复制导致的延迟(数据一致性)
基于AWS dynamoDB的CQRS的实例介绍

外部API模式 (省略)
API Gateway模式
使用后端前置模式解决API Gateway模式带来的职责混乱问题
使用GraphQL实现API Gateway

微服务的测试(上下) (省略)
微服务的安全，配置化，可观测性 (省略)
微服务的部署 (省略)

微服务架构的重构策略
将单体重构为微服务的策略: (重构过程漫长，不宜一步到位)
1. 将新功能实现为服务 (新服务与单体通过api gateway集成，由api gateway路由服务请求)
2. 隔离表现层和后端 (前后端分离)
3. 通过将功能提取到服务中来分解单体 (涉及领域模型拆分，数据库重构)


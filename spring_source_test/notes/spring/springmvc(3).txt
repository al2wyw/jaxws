validation, data binding, type conversion:

org.springframework.validation.Validator interface:
• supports(Class) - Can this Validator validate instances of the supplied Class?
• validate(Object, org.springframework.validation.Errors) - validates the given
object and in case of validation errors, registers those with the given Errors object
ValidationUtils class: rejectIfEmpty(..) method

Validation errors are reported to the Errors object passed to the validator. In case of Spring Web MVC
you can use <spring:bind/> tag to inspect the error messages

Resolve codes to error messages:
By default, the DefaultMessageCodesResolver is used, which for example not only registers a message with
the code you gave, but also messages that include the field name you passed to the reject method.

the BeanWrapper (BeanWrapperImpl)
offers functionality to set and get property values (individually or in bulk), get property descriptors, and to
query properties to determine if they are readable or writable and so on...
The BeanWrapper usually isn't used by application code directly, but by the DataBinder and the BeanFactory.

Spring uses the concept of PropertyEditors to effect the conversion between an Object and a String.
Most,but not all (as indicated below), are registered by default by BeanWrapperImpl.

Spring uses the java.beans.PropertyEditorManager to set the search path for property
editors that might be needed. The search path also includes sun.bean.editors, which includes
PropertyEditor implementations for types such as Font, Color, and most of the primitive types.
Note also that the standard JavaBeans infrastructure will automatically discover PropertyEditor
classes (without you having to register them explicitly) if they are in the same package as the class
they handle, and have the same name as that class, with 'Editor' appended

BeanInfo ???

CustomEditorConfigurer a bean factory postprocessor,
may be used to conveniently add support for additional PropertyEditor instances to an ApplicationContext.
public class ExoticType {
	private String name;
	public ExoticType(String name) {
		this.name = name;
	}
}
public class ExoticTypeEditor extends PropertyEditorSupport {
	public void setAsText(String text) {
		setValue(new ExoticType(text.toUpperCase()));
	}
}
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
	<property name="customEditors">
		<map>
			<entry key="example.ExoticType" value="example.ExoticTypeEditor"/>
		</map>
	</property>
</bean>

org.springframework.beans.support.ResourceEditorRegistrar
PropertyEditorRegistrar exposes a property called setPropertyEditorRegistrars(..): PropertyEditorRegistrars added to
a CustomEditorConfigurer in this fashion can easily be shared with DataBinder and Spring
MVC Controllers. Furthermore, it avoids the need for synchronization on custom editors: a
PropertyEditorRegistrar is expected to create fresh PropertyEditor instances for each bean
creation attempt.
public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {
	public void registerCustomEditors(PropertyEditorRegistry registry) {
		// it is expected that new PropertyEditor instances are created
		registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());
		// you could register as many custom property editors as are required here...
	}
}
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
	<property name="propertyEditorRegistrars">
		<list>
			<ref bean="customPropertyEditorRegistrar"/>
		</list>
	</property>
</bean>
<bean id="customPropertyEditorRegistrar" class="com.foo.editors.spring.CustomPropertyEditorRegistrar"/>

Converter SPI (implement this interface)
The SPI to implement type conversion logic is simple and strongly typed:
package org.springframework.core.convert.converter;
public interface Converter<S, T> {
	T convert(S source);
}

ConverterFactory
package org.springframework.core.convert.converter;
public interface ConverterFactory<S, R> {
	<T extends R> Converter<S, T> getConverter(Class<T> targetType);
}
final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {
	public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {
		return new StringToEnumConverter(targetType);
	}
	private final class StringToEnumConverter<T extends Enum> implements Converter<String,T> {
		private Class<T> enumType;
		public StringToEnumConverter(Class<T> enumType) {
			this.enumType = enumType;
		}
		public T convert(String source) {
			return (T) Enum.valueOf(this.enumType, source.trim());
		}
	}
}

GenericConverter
public interface GenericConverter {
	public Set<ConvertiblePair> getConvertibleTypes();
	Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
getConvertibleTypes() return the supported source->target
type pairs. Then implement convert(Object, TypeDescriptor, TypeDescriptor) to implement your
conversion logic. The source TypeDescriptor provides access to the source field holding the value being
converted. The target TypeDescriptor provides access to the target field where the converted value will
be set.

public interface ConditionalGenericConverter extends GenericConverter {
	boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
}

ConversionService
public interface ConversionService {
	boolean canConvert(Class<?> sourceType, Class<?> targetType);
	<T> T convert(Object source, Class<T> targetType);
	boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);
	Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
Most ConversionService implementations also implement ConverterRegistry, which provides an
SPI for registering converters.
A robust ConversionService implementation is provided in the core.convert.support package.
GenericConversionService is the general-purpose implementation suitable for use in most
environments. ConversionServiceFactory provides a convenient factory for creating common
ConversionService configurations.

If no ConversionService is registered with Spring, the original PropertyEditor-based system is
used.
<bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
	<property name="converters">
		<list>
			<bean class="example.MyCustomConverter"/>
		</list>
	</property>
</bean>

Formatter:
public interface Formatter<T> extends Printer<T>, Parser<T> {
}
public interface Printer<T> {
String print(T fieldValue, Locale locale);
}
public interface Parser<T> {
T parse(String clientValue, Locale locale) throws ParseException;
}
Several Formatter implementations are provided in format subpackages as a convenience. The
number package provides a NumberFormatter, CurrencyFormatter, and PercentFormatter to format
java.lang.Number objects using a java.text.NumberFormat. The datetime package provides a
DateFormatter to format java.util.Date objects with a java.text.DateFormat.

Annotation-driven Formatting ???

Format Annotation API
A portable format annotation API exists in the org.springframework.format.annotation
package. Use @NumberFormat to format java.lang.Number fields. Use @DateTimeFormat to format
java.util.Date, java.util.Calendar, java.util.Long

FormatterRegistry SPI
The FormatterRegistry is an SPI for registering formatters and converters.
FormattingConversionService is an implementation of FormatterRegistry suitable for most
environments.
Formatters can be registered by fieldType or annotation.

FormatterRegistrar SPI
The FormatterRegistrar is an SPI for registering formatters and converters through the
FormatterRegistry:
public interface FormatterRegistrar {
void registerFormatters(FormatterRegistry registry);
}

Configuring Formatting in Spring MVC
To rely on default formatting rules, no custom configuration is required in your Spring MVC config XML: just add <mvc:annotation-driven/> on configuration XML.
Otherwise to use custom converter and formatters:
<mvc:annotation-driven conversion-service="conversionService"/>
<bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
	<property name="converters">
		<set>
			<bean class="org.example.MyConverter"/>
		</set>
	</property>
	<property name="formatters">
		<set>
			<bean class="org.example.MyFormatter"/>
			<bean class="org.example.MyAnnotationFormatterFactory"/>
		</set>
	</property>
	<property name="formatterRegistrars">
		<set>
			<bean class="org.example.MyFormatterRegistrar"/>
		</set>
	</property>
</bean>

Configuring a global date & time format ???

Spring Validation:
First, the JSR-303 Bean Validation
API is now fully supported. Second, when used programmatically, Spring's DataBinder can now validate
objects as well as bind to them. Third, Spring MVC now has support for declaratively validating @Controller inputs.

JSR-303 Bean Validation API ???

Configuring a Bean Validation Implementation ???

Configuring a DataBinder ???

Spring MVC 3 Validation
To trigger validation of a @Controller input, simply annotate the input argument as @Valid:
Spring MVC will validate a @Valid object after binding so-long as an appropriate Validator has been
configured.

Configuring a Validator for use by Spring MVC
The Validator instance invoked when a @Valid method argument is encountered may be configured in
two ways:
First, you may call binder.setValidator(Validator) within a @Controller's @InitBinder callback.
This allows you to configure a Validator instance per @Controller class.Second, you may call setValidator(Validator) on the global WebBindingInitializer.
<mvc:annotation-driven validator="globalValidator"/>

Configuring a JSR-303 Validator for use by Spring MVC
To configure a JSR-303-backed Validator with Spring MVC, simply
add a JSR-303 Provider, such as Hibernate Validator, to your classpath.
<mvc:annotation-driven/>

///////////////////////////////////////////////////////////////////////////////

Spring MVC

The DispatcherServlet
In the Web MVC framework, each
DispatcherServlet has its own WebApplicationContext, which inherits all the beans already
defined in the root WebApplicationContext. These inherited beans can be overridden in the Servlet specific scope

Upon initialization of a DispatcherServlet, Spring MVC looks for a file named [servlet-name]-
servlet.xml in the WEB-INF directory of your web application

The WebApplicationContext is an extension of the plain ApplicationContext that has some
extra features necessary for web applications. It differs from a normal ApplicationContext in that it
is capable of resolving themes (see Section 17.9, “Using themes”), and that it knows which Servlet it is
associated with (by having a link to the ServletContext).

DispatcherServlet Processing Sequence:
1. The WebApplicationContext is searched for and bound in the request as an attribute that
the controller and other elements in the process can use. It is bound by default under the key
DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE.
2. The locale resolver is bound to the request to enable elements in the process to resolve the locale
to use when processing the request (rendering the view, preparing data, and so on). If you do not
need locale resolving, you do not need it.
3. The theme resolver is bound to the request to let elements such as views determine which theme to
use. If you do not use themes, you can ignore it.
4. If you specify a multipart file resolver, the request is inspected for multiparts; if multiparts are found, the
request is wrapped in a MultipartHttpServletRequest for further processing by other elements
in the process. See Section 17.10, “Spring's multipart (file upload) support” for further information
about multipart handling.
5. An appropriate handler is searched for. If a handler is found, the execution chain associated with
the handler (preprocessors, postprocessors, and controllers) is executed in order to prepare a model
or rendering.
6. If a model is returned, the view is rendered. If no model is returned, (may be due to a preprocessor or
postprocessor intercepting the request, perhaps for security reasons), no view is rendered, because
the request could already have been fulfilled.

The process of determining the last modification date for a specific request is
straightforward: the DispatcherServlet looks up an appropriate handler mapping and tests whether
the handler that is found implements the LastModified interface. If so, the value of the long
getLastModified(request) method of the LastModified interface is returned to the client.

The @Controller annotation indicates that a particular class serves the role of a controller.
To enable autodetection of such annotated controllers, you add component scanning to your
configuration. Use the spring-context schema as shown in the following XML snippet:
<context:component-scan base-package="org.springframework.samples.petclinic.web"/>

Proxy with @RequestMapping: !!!
Usually you will introduce an interface for the controller in order to use JDK
dynamic proxies. To make this work you must move the @RequestMapping annotations to
the interface as well as the mapping mechanism can only "see" the interface exposed by the
proxy. Alternatively, you could activate proxy-target-class="true" in the configuration
for the functionality applied to the controller

URI Template Patterns
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable("ownerId") String theOwner, Model model) {
// implementation omitted
}
or omit "ownerId" if the variable name matches:
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
// implementation omitted
}

When a @PathVariable annotation is used on a Map<String, String> argument, the map is
populated with all URI template variables  ???

A @PathVariable argument can be of any simple type such as int, long, Date, etc. Spring
automatically converts to the appropriate type or throws a TypeMismatchException if it fails to do so.

The @RequestMapping annotation supports the use of regular expressions in URI template variables.
The syntax is {varName:regex}

each matrix variable separated with a
";" (semicolon). For example: "/cars;color=red;year=2012". Multiple values may be either
"," (comma) separated "color=red,green,blue" or the variable name may be repeated
"color=red;color=green;color=blue".

// GET /owners/42;q=11/pets/21;q=22
@RequestMapping(value = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)
public void findPet(
@MatrixVariable(value="q", pathVar="ownerId") int q1,
@MatrixVariable(value="q", pathVar="petId") int q2) {
// q1 == 11
// q2 == 22
}

// GET /pets/42
@RequestMapping(value = "/pets/{petId}", method = RequestMethod.GET)
public void findPet(@MatrixVariable(required=true, defaultValue="1") int q) {
// q == 1
}

// GET /owners/42;q=11;r=12/pets/21;q=22;s=23
@RequestMapping(value = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)
public void findPet(
@MatrixVariable Map<String, String> matrixVars,
@MatrixVariable(pathVar="petId") Map<String, String> petMatrixVars) {
// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
// petMatrixVars: ["q" : 11, "s" : 23]
}

The consumes condition is supported on the class and on the method level. Unlike most other
conditions, when used at the class level, method-level consumable types override rather than
extend class-level consumable types.(the same as producible types)

@RequestMapping(value = "/pets/{petId}", method = RequestMethod.GET, params="myParam=myValue")
@RequestMapping(value = "/pets", method = RequestMethod.GET, headers="myHeader=myValue")
Although you can match to Content-Type and Accept header values using media type wild cards
(for example "content-type=text/*" will match to "text/plain" and "text/html"), it is recommended to
use the consumes and produces conditions respectively instead. They are intended specifically
for that purpose

Defining @RequestMapping handler methods (a long list of parameters and return types)

Supported method argument types:
1. Request or response objects (Servlet API).ServletRequest or HttpServletRequest.

2. Session object (Servlet API): of type HttpSession.
Session access may not be thread-safe, in particular in a Servlet environment. Consider setting
the RequestMappingHandlerAdapter's "synchronizeOnSession" flag to "true" if multiple
requests are allowed to access a session concurrently.

3.org.springframework.web.context.request.WebRequest or org.springframework.web.context.request.NativeWebRequest. 
Allows for generic request parameter access as well as request/session attribute access, without ties to the native
Servlet/Portlet API.

4.java.util.Locale for the current request locale, determined by the most specific locale resolver
available, in effect, the configured LocaleResolver in a Servlet environment.

5.java.io.InputStream / java.io.Reader for access to the request’s content. This value is the
raw InputStream/Reader as exposed by the Servlet API.

6.java.io.OutputStream / java.io.Writer for generating the response’s content. This value is
the raw OutputStream/Writer as exposed by the Servlet API.

7.java.security.Principal containing the currently authenticated user.

8. @PathVariable @MatrixVariable @RequestParam @RequestHeader @RequestBody @RequestPart

9. HttpEntity<?> parameters for access to the Servlet request HTTP headers and contents. The
request stream will be converted to the entity body using HttpMessageConverters.

10.java.util.Map / org.springframework.ui.Model /
org.springframework.ui.ModelMap for enriching the implicit model that is exposed to the web
view.

11. org.springframework.web.servlet.mvc.support.RedirectAttributes to specify the
exact set of attributes to use in case of a redirect and also to add flash attributes (attributes
stored temporarily on the server-side to make them available to the request after the redirect).
RedirectAttributes is used instead of the implicit model if the method returns a "redirect:"
prefixed view name or RedirectView.

12.Command or form objects to bind request parameters to bean properties (via setters), depending on @InitBinder methods
and/or the HandlerAdapter configuration. See the webBindingInitializer property on
RequestMappingHandlerAdapter. Such command objects along with their validation results will
be exposed as model attributes by default, using the command class class name. The ModelAttribute
annotation can be used on a method argument to customize the model attribute name used.

13.org.springframework.validation.Errors /
org.springframework.validation.BindingResult validation results for a preceding
command or form object

14.org.springframework.web.bind.support.SessionStatus status handle for marking form
processing as complete, which triggers the cleanup of session attributes that have been indicated by
the @SessionAttributes annotation at the handler type level.

15.org.springframework.web.util.UriComponentsBuilder a builder for preparing a URL
relative to the current request’s host, port, scheme, context path, and the literal part of the servlet
mapping.

The Errors or BindingResult parameters have to follow the model object that is being bound
immediately as the method signature might have more than one model object and Spring will create a
separate BindingResult instance for each of them: (model between ModelAttribute and result is wrong)
@RequestMapping(method = RequestMethod.POST)
public String processSubmit(@ModelAttribute("pet") Pet pet, Model model, BindingResult
result) { ... }
@RequestMapping(method = RequestMethod.POST)
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result, Model
model) { ... }

Supported method return types:
1. A ModelAndView object

2. A Model object, with the view name implicitly determined through a RequestToViewNameTranslator

3. A Map object for exposing a model, with the view name implicitly determined through a RequestToViewNameTranslator

4. A View object, The handler method may also
programmatically enrich the model by declaring a Model argument

5. A String value that is interpreted as the logical view name,The handler method may also
programmatically enrich the model by declaring a Model argument

6. void if the method handles the response itself (by writing the response content directly, declaring
an argument of type ServletResponse / HttpServletResponse for that purpose) or if the view
name is supposed to be implicitly determined through a RequestToViewNameTranslator (not
declaring a response argument in the handler method signature).

7. If the method is annotated with @ResponseBody, the return type is written to the response
HTTP body. The return value will be converted to the declared method argument type using
HttpMessageConverters

8. A HttpEntity<?> or ResponseEntity<?> object to provide access to the Servlet response
HTTP headers and contents. The entity body will be converted to the response stream using
HttpMessageConverters.

9. A Callable<?> can be returned when the application wants to produce the return value
asynchronously in a thread managed by Spring MVC.
A DeferredResult<?> can be returned when the application wants to produce the return value
from a thread of its own choosing.

10. Any other return type is considered to be a single model attribute to be exposed to the view, using
the attribute name specified through @ModelAttribute at the method level (or the default attribute
name based on the return type class name).

Binding request parameters to method parameters with @RequestParam
Parameters using this annotation are required by default, but you can specify that a parameter is optional
by setting @RequestParam's required attribute to false (e.g., @RequestParam(value="id",required=false)).
Type conversion is applied automatically if the target method parameter type is not String. See the
section called “Method Parameters And Type Conversion”.

Mapping the request body with the @RequestBody annotation
You convert the request body to the method argument by using an HttpMessageConverter.
The RequestMappingHandlerAdapter supports the @RequestBody annotation with the following default HttpMessageConverters:
• ByteArrayHttpMessageConverter converts byte arrays.
• StringHttpMessageConverter converts strings.
• FormHttpMessageConverter converts form data to/from a MultiValueMap<String, String>.
• SourceHttpMessageConverter converts to/from a javax.xml.transform.Source.
If you intend to read and write XML, you will need to configure the
MarshallingHttpMessageConverter with a specific Marshaller and an Unmarshaller
implementation from the org.springframework.oxm package:(P459)

An @RequestBody method parameter can be annotated with @Valid, in which case it will be validated
using the configured Validator instance. When using the MVC namespace or the MVC Java config,
a JSR-303 validator is configured automatically assuming a JSR-303 implementation is available on
the classpath.

Creating REST Controllers with the @RestController annotation
@RestController is a stereotype annotation that combines @ResponseBody and @Controller.
More than that, it gives more meaning to your Controller and also may carry additional semantics in
future releases of the framework.

Using HttpEntity
The HttpEntity is similar to @RequestBody and @ResponseBody. Besides getting access to the
request and response body, HttpEntity (and the response-specific subclass ResponseEntity) also
allows access to the request and response headers,

Using @ModelAttribute on a method
An @ModelAttribute on a method indicates the purpose of that method is to add one or more model
attributes.@ModelAttribute methods in a controller are invoked before
@RequestMapping methods, within the same controller. A couple of examples:(two styles)
@ModelAttribute
public Account addAccount(@RequestParam String number) {
return accountManager.findAccount(number);
}
// Add multiple attributes
@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
model.addAttribute(accountManager.findAccount(number));
// add more ...
}

@ModelAttribute methods can also be defined in an @ControllerAdvice-annotated class and
such methods apply to all controllers.

The @ModelAttribute annotation can be used on @RequestMapping methods as well. In that case
the return value of the @RequestMapping method is interpreted as a model attribute rather than as
a view name.

Using @ModelAttribute on a method argument
@RequestMapping(value="/owners/{ownerId}/pets/{petId}/edit", method = RequestMethod.POST)
public String processSubmit(@ModelAttribute Pet pet) {
}
Given the above example where can the Pet instance come from? There are several options:
• It may already be in the model due to use of @SessionAttributes — see the section called “Using
@SessionAttributes to store model attributes in the HTTP session between requests”.
• It may already be in the model due to an @ModelAttribute method in the same controller — as
explained in the previous section.
• It may be retrieved based on a URI template variable and type converter
• It may be instantiated using its default constructor.

@RequestMapping(value="/accounts/{account}", method = RequestMethod.PUT)
public String save(@ModelAttribute("account") Account account) {
}
In this example the name of the model attribute (i.e. "account") matches the name of a URI template
variable. If you register Converter<String, Account> that can turn the String account value into
an Account instance.
The next step is data binding. The WebDataBinder class matches request parameter names ¡ª
including query string parameters and form fields ¡ª to model attribute fields by name.
To check for such errors add a BindingResult argument immediately following the @ModelAttribute argument:
@RequestMapping(value="/accounts/{account}", method = RequestMethod.PUT)
public String save(@ModelAttribute("account") Account account, BindingResult result) {
if (result.hasErrors()) {
return "accountForm";
}
// ...
}
In addition to data binding you can also invoke validation using your own custom validator passing the
same BindingResult that was used to record data binding errors.
@RequestMapping(value="/accounts/{account}", method = RequestMethod.PUT)
public String save(@ModelAttribute("account") Account account, BindingResult result) {
new PetValidator().validate(account, result);
if (result.hasErrors()) {
return "accountForm";
}
// ...
}
Or you can have validation invoked automatically by adding the JSR-303 @Valid annotation:
@RequestMapping(value="/accounts/{account}", method = RequestMethod.PUT)
public String save(@Valid @ModelAttribute("account") Account account, BindingResult result) {
if (result.hasErrors()) {
return "accountForm";
}
// ...
}

Using @SessionAttributes to store model attributes
The class-level @SessionAttributes annotation declares session attributes used by a specific handler.
When using controller interfaces (e.g., for AOP proxying), make sure to consistently put all
your mapping annotations - such as @RequestMapping and @SessionAttributes - on the
controller interface rather than on the implementation class.

Specifying redirect and flash attributes:
By default all model attributes are considered to be exposed as URI template variables in the redirect
URL. Of the remaining attributes those that are primitive types or collections/arrays of primitive types
are automatically appended as query parameters. (???)
an @RequestMapping method can declare an argument of type
RedirectAttributes and use it to add attributes for use in RedirectView. If the controller method
does redirect, the content of RedirectAttributes is used. Otherwise the content of the default
Model is used.

The RequestMappingHandlerAdapter provides a flag called
"ignoreDefaultModelOnRedirect" that can be used to indicate the content of the default Model
should never be used if a controller method redirects.
Both the MVC namespace and the MVC Java config keep this flag set to false in
order to maintain backwards compatibility.

The RedirectAttributes interface can also be used to add flash attributes.

Working with "application/x-www-form-urlencoded" data (PUT / PATCH)
<filter>
<filter-name>httpPutFormFilter</filter-name>
<filter-class>org.springframework.web.filter.HttpPutFormContentFilter</filter-class>
</filter>
<filter-mapping>
<filter-name>httpPutFormFilter</filter-name>
<servlet-name>dispatcherServlet</servlet-name>
</filter-mapping>
The above filter intercepts HTTP PUT and PATCH requests with content type application/
x-www-form-urlencoded, reads the form data from the body of the request, and
wraps the ServletRequest in order to make the form data available through the
ServletRequest.getParameter*()

The @CookieValue annotation allows a method parameter to be bound to the value of an HTTP cookie
public void displayHeaderInfo(@CookieValue("JSESSIONID") String cookie)
The @RequestHeader annotation allows a method parameter to be bound to a request header.
Built-in support is available for converting a comma-separated string into an array/collection of
strings or other types known to the type conversion system.
@RequestHeader("Accept") may be of type String but also String[] or List<String>.

Method Parameters And Type Conversion
You can further customize the conversion process
through a WebDataBinder or by registering Formatters with the FormattingConversionService (see Section 7.6, Spring 3 Field
Formatting).

Customizing WebDataBinder initialization:
To customize request parameter binding with PropertyEditors through Spring's WebDataBinder, you
can use @InitBinder-annotated methods within your controller, @InitBinder methods within an
@ControllerAdvice class,or provide a custom WebBindingInitializer.

Init-binder methods must not have
a return value. Thus, they are usually declared as void. Typical arguments include WebDataBinder
in combination with WebRequest or java.util.Locale, allowing code to register context-specific
editors.
@Controller
public class MyFormController {
@InitBinder
public void initBinder(WebDataBinder binder) {
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
dateFormat.setLenient(false);
binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
}
// ...
}

Configuring a custom WebBindingInitializer:
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
	<property name="cacheSeconds" value="0" />
	<property name="webBindingInitializer">
		<bean class="org.springframework.samples.petclinic.web.ClinicBindingInitializer" />
	</property>
</bean>

Support for the 'Last-Modified' Response Header To Facilitate Content Caching  ???
@RequestMapping
public String myHandleMethod(WebRequest webRequest, Model model) {
	long lastModified = // 1. application-specific calculation
	if (request.checkNotModified(lastModified)) {
		// 2. shortcut exit - no further processing necessary
		return null;
	}
	// 3. or otherwise further request processing, actually preparing content
	model.addAttribute(...);
	return "myViewName";
}
two points: calling request.checkNotModified(lastModified) and
returning null. The former sets the response status to 304. The latter, in
combination with the former, causes Spring MVC to do no further processing of the request.

Asynchronous Request Processing ???

(RequestMappingHandlerMapping is a HandlerMapping)
all HandlerMapping classes extending from
AbstractHandlerMapping have the following properties that you can use to customize their behavior:
interceptors
List of interceptors to use. HandlerInterceptors are discussed in the section called “Intercepting
requests with a HandlerInterceptor”.

defaultHandler
Default handler to use, when this handler mapping does not result in a matching handler.

order
Based on the value of the order property (see the org.springframework.core.Ordered
interface), Spring sorts all handler mappings available in the context and applies the first matching
handler.

alwaysUseFullPath
If true , Spring uses the full path within the current Servlet context to find an appropriate handler.
If false (the default), the path within the current Servlet mapping is used. For example, if a Servlet
is mapped using /testing/* and the alwaysUseFullPath property is set to true, /testing/
viewPage.html is used, whereas if the property is set to false, /viewPage.html is used.

urlDecode
Defaults to true, as of Spring 2.5. If you prefer to compare encoded paths, set this flag to false.
However, the HttpServletRequest always exposes the Servlet path in decoded form. Be aware
that the Servlet path will not match when compared with encoded paths.

Intercepting requests with a HandlerInterceptor
This interface defines three methods:
preHandle(..) is called before the actual handler is executed; postHandle(..) is called after
the handler is executed; and afterCompletion(..) is called after the complete request has
finished.
<bean id="handlerMapping" class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"> //bound to RequestMappingHandlerMapping, all the requests handled by this mapping will be intercepted 
	<property name="interceptors">
		<bean class="example.MyInterceptor"/> //extends HandlerInterceptorAdapter
	</property>
</bean>

When using the RequestMappingHandlerMapping the actual handler is an instance of
HandlerMethod which identifies the specific controller method that will be invoked.

Views in Spring are addressed by a logical view name and are resolved by a view resolver.
UrlBasedViewResolver 
Simple implementation of the ViewResolver interface that effects
the direct resolution of logical view names to URLs,This is appropriate if your logical names
match the names of your view resources.

InternalResourceViewResolver
subclass of UrlBasedViewResolver that supports
InternalResourceView (in effect, Servlets and JSPs) and
subclasses such as JstlView and TilesView. You can
specify the view class for all views generated by this resolver
by using setViewClass(..).

VelocityViewResolver / FreeMarkerViewResolver
Convenient subclass of UrlBasedViewResolver that
supports VelocityView (in effect, Velocity templates) or
FreeMarkerView ,respectively, and custom subclasses of them.
ResourceBundleViewResolver

Implementation of ViewResolver that uses bean definitions in a
ResourceBundle, specified by the bundle base name. Typically
you define the bundle in a properties file, located in the classpath.
The default file name is views.properties.

ContentNegotiatingViewResolver
Implementation of the ViewResolver interface that resolves a
view based on the request file name or Accept header.

Chaining ViewResolvers
You chain view resolvers by adding more than one resolver to your
application context and, if necessary, by setting the order property to specify ordering. Remember, the
higher the order property, the later the view resolver is positioned in the chain.
InternalResourceViewResolver, which is always automatically positioned as the last resolver in
the chain.

If a specific view resolver does not result in a view, Spring examines the context for other view resolvers.
If additional view resolvers exist, Spring continues to inspect them until a view is resolved. If no view
resolver returns a view, Spring throws a ServletException.

The contract of a view resolver specifies that a view resolver can return null to indicate the view could not
be found. Not all view resolvers do this, the resolver simply cannot
detect whether or not the view exists. The InternalResourceViewResolver will always return a view!

Redirecting to views 
It is sometimes desirable to issue an HTTP redirect back to the client, before the view is rendered.

RedirectView
One way to force a redirect as the result of a controller response is for the controller to create and
return an instance of Spring's RedirectView.
The RedirectView issues an HttpServletResponse.sendRedirect() call that returns to the
client browser as an HTTP redirect. By default all model attributes are considered to be exposed as
URI template variables in the redirect URL.Of the remaining attributes those that are primitive types or
collections/arrays of primitive types are automatically appended as query parameters.

an annotated controller can declare an argument of type
RedirectAttributes and use it to specify the exact attributes to make available to RedirectView.
If the controller method decides to redirect, the content of RedirectAttributes is used. Otherwise
the content of the model is used.

The redirect: prefix / The forward: prefix
If a view name is returned that has the
prefix redirect:, the UrlBasedViewResolver (and all subclasses) will recognize this as a special
indication that a redirect is needed. The rest of the view name will be treated as the redirect URL.
The net effect is the same as if the controller had returned a RedirectView.

ContentNegotiatingViewResolver
Use the same URI for the client to locate the resource, but set the Accept HTTP request
header to list the media types that it understands. This strategy is known as content
negotiation.
ContentNegotiatingViewResolver to resolve a view based on the file extension or Accept
header of the HTTP request. ContentNegotiatingViewResolver does not perform the view
resolution itself but instead delegates to a list of view resolvers that you specify through the bean property
ViewResolvers.

The ContentNegotiatingViewResolver selects an appropriate View to handle the request by
comparing the request media type(s) with the media type (also known as Content-Type) supported by
the View associated with each of its ViewResolvers. The first View in the list that has a compatible
Content-Type returns the representation to the client. If a compatible view cannot be supplied by
the ViewResolver chain, then the list of views specified through the DefaultViews property will
be consulted. This latter option is appropriate for singleton Views that can render an appropriate
representation of the current resource regardless of the logical view name.

<bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver">
<property name="mediaTypes">
	<map>
		<entry key="atom" value="application/atom+xml"/>
		<entry key="html" value="text/html"/>
		<entry key="json" value="application/json"/>
	</map>
</property>
<property name="viewResolvers">
	<list>
		<bean class="org.springframework.web.servlet.view.BeanNameViewResolver"/>
		<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
			<property name="prefix" value="/WEB-INF/jsp/"/>
			<property name="suffix" value=".jsp"/>
		</bean>
	</list>
</property>
<property name="defaultViews">
	<list>
		<bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView" />
	</list>
</property>
</bean>

If ContentNegotiatingViewResolver's list of ViewResolvers is not configured explicitly, it
automatically uses any ViewResolvers defined in the application context.

Using flash attributes ???

Building URIs ???

Using locales
Using the RequestContext.getLocale() method, you can always
retrieve the locale that was resolved by the locale resolver.

In addition to automatic locale resolution, you can also attach an interceptor to the handler mapping
to change the locale under specific circumstances. Locale resolvers and interceptors are defined in the org.springframework.web.servlet.i18n
package and are configured in your application context in the normal way

AcceptHeaderLocaleResolver
This locale resolver inspects the accept-language header in the request that was sent by the client.

CookieLocaleResolver
This locale resolver inspects a Cookie that might exist on the client to see if a locale is specified. If so,
it uses the specified locale.

SessionLocaleResolver
The SessionLocaleResolver allows you to retrieve locales from the session that might be
associated with the user's request

LocaleChangeInterceptor
You can enable changing of locales by adding the LocaleChangeInterceptor to one of the handler
mappings. It will detect a parameter in the request and change
the locale.
<bean id="localeChangeInterceptor"
class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">
	<property name="paramName" value="siteLanguage"/>
</bean>
?siteLanguage=nl will change the site language to Dutch.

To use themes in your web application, you must set up an
implementation of the org.springframework.ui.context.ThemeSource interface.
The WebApplicationContext interface extends ThemeSource but delegates
its responsibilities to a dedicated implementation. By default the delegate
will be an org.springframework.ui.context.support.ResourceBundleThemeSource
implementation that loads properties files from the root of the classpath.

Theme resolvers
FixedThemeResolver 
Selects a fixed theme, set using the defaultThemeName property.
SessionThemeResolver
The theme is maintained in the user's HTTP session. It only needs to be set
once for each session, but is not persisted between sessions.
CookieThemeResolver
The selected theme is stored in a cookie on the client.

Spring also provides a ThemeChangeInterceptor that allows theme changes on every request with
a simple request parameter.

Spring's multipart (file upload) support ???

HandlerExceptionResolver
Besides implementing the HandlerExceptionResolver interface, which is only a matter
of implementing the resolveException(Exception, Handler) method and returning a
ModelAndView, you may also use the provided SimpleMappingExceptionResolver or create @ExceptionHandler methods(Such methods may be defined locally within an @Controller or may apply globally to all @RequestMapping methods when defined within an @ControllerAdvice class).

@ExceptionHandler
The HandlerExceptionResolver interface and the SimpleMappingExceptionResolver
implementations allow you to map Exceptions to specific views declaratively along with some optional
Java logic before forwarding to those views. However, in some cases, especially when relying on
@ResponseBody methods rather than on view resolution, it may be more convenient to directly set the
status of the response and optionally write error content to the body of the response.

When declared within a controller such methods apply to exceptions raised by @RequestMapping methods of that contoroller
You can also declare an @ExceptionHandler method within an @ControllerAdvice
class in which case it handles exceptions from @RequestMapping methods from any controller.

@ExceptionHandler(IOException.class)
public ResponseEntity<String> handleIOException(IOException ex) {
// prepare responseEntity
return responseEntity;
}

Much like standard controller methods annotated with a @RequestMapping annotation, the method
arguments and return values of @ExceptionHandler methods can be flexible.The return type can be a String, which is interpreted as a view name, a ModelAndView object, a ResponseEntity, or you can also add the @ResponseBody to have the method return value
converted with message converters and written to the response stream.

Handling Standard Spring MVC Exceptions
The DefaultHandlerExceptionResolver works transparently by setting the status of the response.
BindException 							400 (Bad Request)
ConversionNotSupportedException 		500 (Internal Server Error)
HttpMediaTypeNotAcceptableException 	406 (Not Acceptable)
HttpMediaTypeNotSupportedException 		415 (Unsupported Media Type)
HttpMessageNotReadableException 		400 (Bad Request)
HttpMessageNotWritableException 		500 (Internal Server Error)
HttpRequestMethodNotSupportedException	405 (Method Not Allowed)
MethodArgumentNotValidException 		400 (Bad Request)
MissingServletRequestParameterException 400 (Bad Request)
MissingServletRequestPartException 		400 (Bad Request)
NoSuchRequestHandlingMethodException 	404 (Not Found)
TypeMismatchException 					400 (Bad Request)

@ResponseStatus
A business exception can be annotated with @ResponseStatus. When the exception is raised, the
ResponseStatusExceptionResolver handles it by setting the status of the response accordingly.

When the status of the response is set to an error status code and the body of the response is empty,
Servlet containers commonly render an HTML formatted error page. To customize the default error
page of the container, you can declare an <error-page> element in web.xml.

When writing error information, the status code and the error message set on the
HttpServletResponse can be accessed through request attributes in a controller:
@RequestMapping(value="/error", produces="application/json")
@ResponseBody
public Map<String, Object> handle(HttpServletRequest request) {
	Map<String, Object> map = new HashMap<String, Object>();
	map.put("status", request.getAttribute("javax.servlet.error.status_code"));
	map.put("reason", request.getAttribute("javax.servlet.error.message"));
	return map;
	}

Convention over configuration support
The Controller ControllerClassNameHandlerMapping
it is like we do not use it.

The Model ModelMap (ModelAndView)
The ModelAndView class automatically generates a key for an object when an object is added to it.
The strategy for determining the name for an added object is, to use the short class name of the object's class.
A java.util.HashMap instance added will have the name hashMap generated.
The strategy for generating a name after adding a Set or a List(Array) is to peek into the collection, take the
short class name of the first object in the collection, and use that with List appended to the name.

The View - RequestToViewNameTranslator
The RequestToViewNameTranslator interface determines a logical View name when
no such logical view name is explicitly supplied. It has just one implementation, the
DefaultRequestToViewNameTranslator class.

ETag support ???

the MVC Java config or the MVC namespace:
Enabling the MVC Java Config or the MVC XML Namespace
<mvc:annotation-driven />
The above registers a RequestMappingHandlerMapping, a RequestMappingHandlerAdapter,
and an ExceptionHandlerExceptionResolver (among others) in support of processing
requests with annotated controller methods using annotations such as @RequestMapping ,
@ExceptionHandler, and others:
1. Spring 3 style type conversion through a ConversionService instance in addition to the JavaBeans
PropertyEditors used for Data Binding.
2. Support for formatting Number fields using the @NumberFormat annotation through the
ConversionService.
3. Support for formatting Date, Calendar, Long, and Joda Time fields using the @DateTimeFormat
annotation.
4. Support for validating @Controller inputs with @Valid, if a JSR-303 Provider is present on the
classpath.
5. HttpMessageConverter support for @RequestBody method parameters and @ResponseBody
method return values from @RequestMapping or @ExceptionHandler methods.
This is the complete list of HttpMessageConverters set up by mvc:annotation-driven:
a. ByteArrayHttpMessageConverter converts byte arrays.
b. StringHttpMessageConverter converts strings.
c. ResourceHttpMessageConverter converts to/from org.springframework.core.io.Resource for all media types.
d. SourceHttpMessageConverter converts to/from a javax.xml.transform.Source.
e. FormHttpMessageConverter converts form data to/from a MultiValueMap<String, String>.
f. Jaxb2RootElementHttpMessageConverter converts Java objects to/from XML—added if JAXB2 is present on the classpath.
g. MappingJackson2HttpMessageConverter (or
MappingJacksonHttpMessageConverter) converts to/from JSON—added if Jackson 2 (or
Jackson) is present on the classpath.
h. AtomFeedHttpMessageConverter converts Atom feeds—added if Rome is present on the classpath.
i. RssChannelHttpMessageConverter converts RSS feeds—added if Rome is present on the classpath.

Configuring Converters
<mvc:annotation-driven conversion-service="conversionService">
	<mvc:message-converters>
		<bean class="org.example.MyHttpMessageConverter"/>
		<bean class="org.example.MyOtherHttpMessageConverter"/>
	</mvc:message-converters>
</mvc:annotation-driven>
<bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
	<property name="formatters">
		<list>
		<bean class="org.example.MyFormatter"/>
		<bean class="org.example.MyOtherFormatter"/>
		</list>
	</property>
	<property name="converters">  
       <list>  
	   </list>
	</property>
</bean>

Configuring Interceptors
<mvc:interceptors>
	<bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor" /> //global interceptors
	<mvc:interceptor> //path mapping defined interceptors
		<mvc:mapping path="/"/>
		<mvc:exclude-mapping path="/admin/"/>
		<bean class="org.springframework.web.servlet.theme.ThemeChangeInterceptor" />
	</mvc:interceptor>
</mvc:interceptors>

Configuring Content Negotiation
For file extensions in the request URI, the MVC Java config and the MVC namespace, automatically
register extensions such as .json, .xml, .rss, and .atom if the corresponding dependencies such
as Jackson, JAXB2, or Rome are present on the classpath. Additional extensions may be not need to be
registered explicitly if they can be discovered via ServletContext.getMimeType(String) or the
Java Activation Framework

<mvc:annotation-driven content-negotiation-manager="contentNegotiationManager" />
<bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
	<property name="favorPathExtension" value="false" />
	<property name="favorParameter" value="true" />
	<property name="mediaTypes" >
		<value>
		json=application/json
		xml=application/xml
		</value>
	</property>
</bean>
Note that ContentNegotiatingViewResolver now can also be configured with a
ContentNegotiatingViewResolver, so you can use one instance throughout Spring MVC.(resolver is not manager)

Configuring View Controllers
This is a shortcut for defining a ParameterizableViewController that immediately forwards to a
view when invoked.
<mvc:view-controller path="/" view-name="home"/>

Configuring Serving of Resources
<mvc:resources mapping="/resources/**" location="/public-resources/"/>
or
<mvc:default-servlet-handler/>

FreeMarker 'Settings' and 'SharedVariables' can be passed directly to the FreeMarker Configuration
object managed by Spring by setting the appropriate bean properties on the FreeMarkerConfigurer
bean: (???)
<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
	<property name="templateLoaderPath" value="/WEB-INF/freemarker/"/>
	<property name="freemarkerVariables">
		<map>
		<entry key="xml_escape" value-ref="fmXmlEscape"/>
		</map>
	</property>
</bean>
<bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/>

Bind support and form handling
The bind macros
#springBind / <@spring.bind> requires a 'path' argument which consists of the name of your
command object followed by a period and the name of the field on the command object you wish to bind to.
The optional form of the macro called #springBindEscaped / <@spring.bindEscaped> takes a
second argument and explicitly specifies whether HTML escaping should be used in the status error
messages or values.

Form input generation macros (a list of macros)
• path: the name of the field to bind to (ie "command.name")
• options: a Map of all the available values that can be selected from in the input field. The keys to
the map represent the values that will be POSTed back from the form and bound to the command
object.
• separator: where multiple options are available as discreet elements (radio buttons or checkboxes),
the sequence of characters used to separate each one in the list (ie "<br>").
• attributes: an additional string of arbitrary tags or text to be included within the HTML tag itself. This
string is echoed literally by the macro.
• classOrStyle: for the showErrors macro, the name of the CSS class that the span tag wrapping each
error will use. If no information is supplied (or the value is empty) then the errors will be wrapped in
<b></b> tags.

http://blog.csdn.net/sunitjy/article/details/6782431/
http://jinnianshilongnian.iteye.com/blog/1752171
http://jinnianshilongnian.iteye.com/blog/1423971 (project introduction)
http://redsnow-fenglin.iteye.com/blog/1155228 (messagesource configuration, classpath)


    margin:10px 5px 15px 20px;
        top margin is 10px
        right margin is 5px
        bottom margin is 15px
        left margin is 20px

    margin:10px 5px 15px;
        top margin is 10px
        right and left margins are 5px
        bottom margin is 15px

    margin:10px 5px;
        top and bottom margins are 10px
        right and left margins are 5px

    margin:10px;
        all four margins are 10px

递归下降 -> 消除左递归 怎么快速找到相似代码段???
词法分析就是lexer，也就是tokenize，词法符号包含两部分: 词法符号类型，词法符号文本
语法分析就是parser，生成对应的抽象语法树AST(或者叫parse tree)，语法树的非叶子节点代表语法规则，叶子节点代表了词法符号
LL分析器是一种处理某些上下文无关文法的自顶向下分析器，因为它从左到右处理输入，再对句型执行最左推导出语法树
LR分析器是一种自底向上的上下文无关语法分析器，LR意指由左至右处理输入字符串，并以最右边优先派生（Right derivation）的推导顺序建构语法树
ANTLR是基于LL(*)算法实现的语法解析器生成器(优先使用SLL(*)进行分析，不进行回溯，解析失败后切换为LL(*))，使用自上而下（top-down）的递归下降LL分析器，递归下降的语法分析器仅仅是自上而下语法分析器的一种实现，会通过检查下一个词法符号来做出语法分析决策或者预测(有时需要嗅探完整个文本才能做出决策, 为实现规则的优先级，避免歧义)，ANTLR4解决了左递归规则(直接递归,间接递归无法解决)问题，使用深度优先遍历所有的节点
直接递归: expr: expr '+' expr | INT ; 间接递归: expr: block '+' expr | INT ; block: expr;
歧义性:
语法分析的歧义性:
stat: expr';' | ID '(' ')';
expr: ID '(' ')'
都可以匹配方法调用的字符串'f();'，有歧义，会按照先后顺序匹配，会匹配为 expr';' 而不是 ID '(' ')';
词法分析的歧义性:
BEGIN: 'begin';
ID: [a-z]+;
都可以匹配字符串'begin', 有歧义，会匹配可能的最长字符串，'beginner'会匹配为ID
词法规则以大写字母开头，语法规则以小写字母开头
词法分析指令 语法分析定制
语法设计策略: 自顶向下的分析(嵌套) 语法模式: 序列识别(模式匹配)， 选择(多分支)，词法符号依赖(圆括号，花括号，中括号)，嵌套(递归)
语义判定: 在运行时选择性关闭部分语法(本身是布尔表达式{java5}?)，解决同一语言的多版本解析和处理语法歧义， 可以在语法规则或者词法匹配中使用
语法歧义: 如果语法能够以多种方式匹配输入的文本，语法本身有问题(尽量避免)，但是某些编程语言语法本身是有歧义的(而且必须具备这种歧义)，需要通过输入的具体上下文得到清晰的含义，该输入是上下文相关的
语言识别的棘手问题集中在词法分析中而不是语法分析:
词法符号送入不同通道:
WS: [\t\n\r]+ -> skip; COMMENT: '//' .*? '\n' -> skip; skip就是通道1
WS: [\t\n\r]+ -> channel(1); COMMENT: '//' .*? '\n' -> channel(2); 只有通道0才对lexer可见，其他通道都是隐藏的
可以通过访问隐藏通道来进行COMMENT的格式转换
在词法分析中涉及上下文的三个问题:
相同的字符序列在语法分析器中具有不同的含义(关键词作为变量标识符)：

相同的字符序列可以对应多个词法符号(java中的>>既是两个泛型结束符，也是右移运算)：

相同的字符序列在某些情况需要忽略，另外情况需要被分析(python的物理换行符和逻辑换行符)：

孤岛模式和海洋模式：使用词法模式处理上下文相关的词法符号，词法模式就是允许词法分析在不同的上下文切换。
移除直接左递归:
规则子表达式: 二元，三元，一元前缀，一元后缀，主表达式
运算符结合，一般是左结合，某些是右结合(赋值和指数运算符)，通过<assoc=right>指定结合性
对主表达式以外的规则表达式进行规则转换成复杂的带语义判定的主表达式，使得运算符得到优先级上升(这不是带运算符优先级的语法分析器!!!)
属性和动作 10章 314页，探究运行时API 13章 15章 445页 (未读章节)
使用语义判定修改语法分析过程 11章 338页， 掌握词法分析的“黑魔法” 12章 361页
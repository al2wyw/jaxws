组件聚合
复用/发布等同原则 REP
软件复用的最小颗粒度等同于其发布的最小颗粒度
共同闭包原则 CCP
相同职责的类放在同一个组件，即组件只存在一个变更的原因 (强调相同职责的类的聚集，减少组件数量)
共同复用原则 CRP
不要强迫组件依赖方依赖不需要的类(强调组件的拆分，避免过多不必要的依赖)
REP && CCP : 太多不必要的发布(任何一个模块的修改引起组件内所有模块的发布)；  REP && CRP: 太多的组件变更(任何一个需求引起多个组件的发布变更)； 组件聚合原则实质就是可复用性和可维护性之间的取舍
REP ---- CCP
   \    /
     CRP

组件耦合
无依赖环原则 ADP
依赖环的危害: 无法判断环上的其他组件是否需要更新；部署测试开发成本上升，需要额外引入组件
打破依赖环: 1. DIP依赖反转 2. 把互相依赖的类抽离成立新的组件
组件结构图不是用来描述应用功能的，不具备和应用功能分组互相对应的能力，而是应用在构建性和维护性方面的图，
组件结构图随着系统的变化而变化，不是在系统设计之初就能设计出来

稳定依赖原则 SDP
依赖关系必须朝着更稳定的方向，即难以修改的组件不应该依赖于经常变更的组件；稳定性：依赖的出度/(依赖的入度+出度)
系统并不是需要所有组件都处于高稳定性状态，设计组件架构图是为了决定哪些组件稳定，哪些组件不稳定

稳定抽象原则 SAP
抽象化程度和稳定性保持一致；抽象度: 接口和抽象类数量/所有类数量
系统中总有一部分不应该经常变更，代表了系统的高阶架构设计及业务策略相关的高阶决策，这部分应该放到稳定组件中，同时使用抽象类和接口，使其具备扩展性
而不稳定的组件应该包含具体的实现(抽象化低)，使其容易被修改
稳定抽象主序列图: 痛苦区(0,0): 稳定性高抽象化低；无用区(1,1): 稳定性低抽象化高；组件的稳定抽象要靠近主序列线(0,1到1,0的直线)

什么是软件架构
划分组件的边界和组件的依赖关系，设计系统顶层结构(骨架)，制定相应的开发测试部署运维规范
软件架构师必须是一线程序员
保持可选项
软件有行为价值和架构价值，要保证架构价值的方法是尽可能长时间保留尽可能多的可选项，
系统一般可以降解为高阶策略(业务规则与操作过程)和底层细节(技术实现，即可选项)，系统以策略为最基本元素，让细节与策略脱离，并延迟细节的决策
独立性(架构的独立性带来开发，部署的独立性，组件之间的解耦)
按层解耦：系统可以被解耦成若干个水平分层 -- UI界面，应用独有的业务逻辑，领域普适的业务逻辑，数据存储等
按用例解耦: 用例是系统水平分层的一个个垂直切片，每个用例都有自己独立的UI，应用逻辑，业务逻辑和数据存储等
不要害怕垂直切分带来的代码"重复"，两段代码表面上看是重复的，但是走不同的演进路径，有着不同的变更频率和原因，因此不算是真正的重复
解耦模式
源码层次(通过一个执行文件加载到内存) -> 部署(类库)层次(通过库文件函数调用交互) -> 服务层次(通过网络调用交互);
系统的解耦推行到一旦需要就可以随时转变为服务的程度即可，即良好的架构容许系统从单体结构开始，然后逐步成长为一组可部署的独立单元，甚至是独立的服务

划分边界
软件架构就是划分边界的艺术，划分边界是为了尽量将一些决策(业务用例无关的技术细节)延后并确保这些决策不会影响核心业务逻辑
一个系统最消耗人力的是系统中的耦合，特别是过早做出的，不成熟的决策(业务用例无关的技术细节)导致的耦合
使用依赖倒置，保证业务逻辑模块被数据库模块，GUI(输入，输出)模块所依赖，从而形成插件式的架构(业务核心以外的模块可以被替换)；边界线应该沿着变革轴来画，边界两边的组件有不同的变更原因和频率
边界剖析
跨边界调用，无论使用哪种解耦模式，高层次模块(业务核心)调用低层次模块时，使用依赖倒置，接口和数据模型定义在高层次模块中，低层次模块永远依赖于高层次模块
策略与层次
软件系统就是策略的集合，策略就是软件功能，软件架构就是把策略彼此分离，按照变更的原因，时间和层次把策略归属同一个组件，并且对组件进行排列组合成为一个有向无环图，一个设计良好的架构依赖关系指向高层组件
业务逻辑
业务实体 -> 高层次
业务用例 -> 底层次 用例描述的是特定的场景下的业务规则，业务实体是脱离场景存在的一般化概念，用例更靠近输入输出，越靠近输入输出层次越低

尖叫的软件架构
架构设计的核心目标：围绕着用例来展开，而不是框架和工具，架构能够凸显软件的用例，类似于房屋的架构设计，着重于房屋的用途而尽可能脱离建筑材料，允许用户尽量延后并自由地选择材料
简洁架构
六边形架构: 端口与适配器架构
简洁架构(依赖关系方向): 实体(系统级业务逻辑) <- 用例(应用级业务逻辑) <- 控制器 展示器(接口适配器) <- 数据库 Web 外部接口 用户界面(框架和驱动程序)
特点: 独立于框架 可被测试 独立于UI 独立于数据库 独立于外部接口
谦卑对象: 把行为类对象划分为容易测试和难以测试的部分，难以测试的部分为谦卑对象，GUI被划分为视图(谦卑对象)和展示器，展示器负责数据加工，视图负责传递可视化信息
不完全边界 ???
边界与层次: 架构师需要权衡成本，决定哪里需要设计架构边界，以及这些地方需要的是完全边界，还是不完全边界，还是可以忽略的边界 ???

服务：宏观与微观
服务解耦的谬论，服务化不能完全解耦组件，面对横跨型需求会引起的大量服务组件变更，只有一开始设计出一系列多态化的类(策略模式)，才能应对将来新功能的扩展
虽然服务化可以提升系统的扩展性和研发性，但是服务本身不能代表系统的架构设计，系统的架构是由系统内部的架构边界，以及边界之间的依赖关系所定义
测试边界
可测试性设计，软件设计的第一原则，就是不用依赖于多变的东西，也就是测试代码与系统耦合，它随着系统变更而变更，因为GUI往往是多变的，因此我们在系统设计与测试设计时，应该让业务逻辑不通过GUI也可以被测试
拾遗
按层封装 按功能封装 按组件封装

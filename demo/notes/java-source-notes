1.lock & thread pool
2.thread
3.class loader
4.reflection & proxy
5.nio & byte buffer

Thread:
1.init方法继承了很多parent thread(当前线程的创建线程)的字段，threadGroup一定会有，也是来自parent thread
2.start的时候会把当前thread加入到group
3.parkBlocker是给park使用的，blocker是给interrupt使用的
4.inheritableThreadLocals继承自parent thread的inheritableThreadLocals
5.join调用时caller线程进行 while (isAlive()) { wait(0); } 操作，等待目标线程死亡，目标线程死亡后会notifyAll
6.public UncaughtExceptionHandler getUncaughtExceptionHandler() {
        return uncaughtExceptionHandler != null ?
            uncaughtExceptionHandler : group; (group的默认实现 Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, e))
    }
7.isCCLOverridden 跟getContextClassLoader有关???


Exception:
1.如果一个异常是致命的，不可恢复的。或者调用者去捕获它没有任何益处，使用unChecked异常。
如果一个异常是可以恢复的，可以被调用者正确处理的，使用checked异常。
在使用unChecked异常时，必须在在方法声明中详细的说明该方法可能会抛出的unChekced异常。由调用者自己去决定是否捕获unChecked异常
2.为了避免系统级的checked异常对业务系统的深度侵入，我们可以为业务方法定义一个业务系统自己的异常。针对像SQLException,RemoteException这些非常严重的异常，我们可以新定义一个unChecked的异常，然后把SQLException，RemoteException封装成unChecked异常后抛出。如果这个系统级的异常是要交由上一级调用者处理的，可以新定义一个checked的业务异常，然后把系统级的异常封存装成业务级的异常后再抛出。
3. 整个业务层只定义了一个异常类 (不同的异常应该有不同的实现，参考spring的异常设计)，业务异常不应该是Unchecked Exception。 顶层处理异常时只有catch一个Exception。
4. 关于异常控制业务流程，参考"Java异常处理和设计"网页
1.lock & thread pool
2.thread
3.class loader
4.reflection & proxy
5.nio & byte buffer

Thread:
1.init方法继承了很多parent thread(当前线程的创建线程)的字段，threadGroup一定会有，也是来自parent thread
2.start的时候会把当前thread加入到group
3.parkBlocker是给park使用的，blocker是给interrupt使用的
4.inheritableThreadLocals继承自parent thread的inheritableThreadLocals
5.join调用时caller线程进行 while (isAlive()) { wait(0); } 操作，等待目标线程死亡，目标线程死亡后会notifyAll
6.public UncaughtExceptionHandler getUncaughtExceptionHandler() {
        return uncaughtExceptionHandler != null ?
            uncaughtExceptionHandler : group; (group的默认实现 Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, e))
    }
7.isCCLOverridden 跟getContextClassLoader有关???

ClassLoader:
1. ParallelLoaders: 并行加载class，每个class都有一个锁，URLClassLoader和ClassLoader都是并行加载器
2. loadClass: findLoadedClass(current loader is initiating classloader) -> parent -> findClass(defineClass,current loader is defining classloader) -> resolveClass
3. initiating class loader/defining class loader
4. protected final Class<?> defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError
{
	protectionDomain = preDefineClass(name, protectionDomain); // ProtectionDomain has CodeSource has Certificate
	String source = defineClassSourceLocation(protectionDomain); //get URL from CodeSource
	Class<?> c = defineClass1(name, b, off, len, protectionDomain, source);//native call defineClass
	postDefineClass(c, protectionDomain); //set Certificate to Class
	return c;
}
5. getResource: parent -> findResource (getResourceAsStream 就是调用 getResource 然后return URL.openStream)
6. getSystemClassLoader 会从sun.misc.Launcher获取classLoader(AppClassLoader), 如果java.system.class.loader有设置的话会用这个作为systemClassLoader(parent是AppClassLoader)
7. AssertionStatus ???
8. package 处理 ???
SecureClassLoader: 
1.只是作一些创建CL的permission检查
2. ProtectionDomain getProtectionDomain(CodeSource cs){
	ProtectionDomain pd = pdcache.get(cs);
	if (pd == null) {
		PermissionCollection perms = getPermissions(cs);// return new Permissions();返回默认的permission列表
		pd = new ProtectionDomain(cs, perms, this, null); pdcache.put(cs, pd);
	}
	return pd;
}
URLClassLoader:
1. 字段: AccessControlContext(创建CL时创建), URLClassPath(承接了所有的find resouce的操作)
2. 复写getResourceAsStream，把inputStream放入closeables, URLClassLoader本身是Closable，close方法会关闭这些closeables以及ucp.closeLoaders()->loader.close()
3. findClass: 
	String path = name.replace('.', '/').concat(".class");
	Resource res = ucp.getResource(path, false);
	if (res != null) {
		try {
			return defineClass(name, res);{
				int i = name.lastIndexOf('.'); URL url = res.getCodeSourceURL();
				if (i != -1) -> definePackageInternal(name.substring(0, i), res.getManifest(), url);//package 校验??? package sealed ???
				CodeSource cs = new CodeSource(url, res.getCodeSigners());
				return defineClass(name, res.getByteBuffer(), cs);//defineClass(name, b, getProtectionDomain(cs))
			}
		} catch (IOException e) {
			throw new ClassNotFoundException(name, e);
		}
	}
4. findResource : URL url= ucp.findResource(name, true);ucp.checkURL(url);(permission校验) //findResources可以把所有URL里面的匹配的resource找出来
5. protected PermissionCollection getPermissions(CodeSource codesource){
	PermissionCollection perms = super.getPermissions(codesource); URL url = codesource.getLocation(); URLConnection urlConnection = url.openConnection();
    Permission  p = urlConnection.getPermission(); 对p进行处理,转换成FilePermission或者SocketPermission;
	check permission; perms.add(p); return perms;
}
URLClassPath: (path <= urls == loaders)
1. public Resource getResource(String name, boolean check) {
        for (int i = 0; (loader = getLoader(i)) != null; i++) {//getLoader 根据URL的数量来创建对等的Loader(Loader,FileLoader,JarLoader), 注意JarLoader可能会根据manifest新增一些URL
            Resource res = loader.getResource(name, check);
            if (res != null) -> return res;
        }
        return null;
    }
2. public URL findResource(String name, boolean check) {
        for (int i = 0; (loader = getLoader(i)) != null; i++) {
            URL url = loader.findResource(name, check);//调用loader.getResource(name, check)
            if (url != null) -> return url;
        }
        return null;
    }
3. Loader getLoader(final URL url){
	String file = url.getFile();
	if (file != null && file.endsWith("/")) {
		if ("file".equals(url.getProtocol())) return new FileLoader(url);
		else return new Loader(url);
	} else return new JarLoader(url, jarHandler, lmap);
}
C:\jre\lib\ext\zipfs.jar -> file:/C:/jre/lib/ext/zipfs.jar -> JarLoader -> getResourc的实现比较复杂 ???
D:\demo\target\classes -> file:/D:/demo/target/classes/ -> FileLoader -> getResource根据目录和name直接创建File并判断是否exist
Resource: 由Loader.getResource返回内部匿名类，封装getResource本地变量的值

URL: 只有一种，但是会根据不同的URLStreamHandler创建不同的URLConnection
URLStreamHandler:
URLConnection:

Exception:
1.如果一个异常是致命的，不可恢复的。或者调用者去捕获它没有任何益处，使用unChecked异常。
如果一个异常是可以恢复的，可以被调用者正确处理的，使用checked异常。
在使用unChecked异常时，必须在在方法声明中详细的说明该方法可能会抛出的unChekced异常。由调用者自己去决定是否捕获unChecked异常
2.为了避免系统级的checked异常对业务系统的深度侵入，我们可以为业务方法定义一个业务系统自己的异常。针对像SQLException,RemoteException这些非常严重的异常，我们可以新定义一个unChecked的异常，然后把SQLException，RemoteException封装成unChecked异常后抛出。如果这个系统级的异常是要交由上一级调用者处理的，可以新定义一个checked的业务异常，然后把系统级的异常封存装成业务级的异常后再抛出。
3. 整个业务层只定义了一个异常类 (不同的异常应该有不同的实现，参考spring的异常设计)，业务异常不应该是Unchecked Exception。 顶层处理异常时只有catch一个Exception。
4. 关于异常控制业务流程，参考"Java异常处理和设计"网页
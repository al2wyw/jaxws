“有符号”右移位操作符 >> （如果最高位是1，则左方补充1）, “无符号”右移位操作符 >>> （无论最高位是什么，左方补充0）。the default is int or double!f F d D l L  no s b c for short byte and charchar c = 0xffff; // max char hex valuebyte b = 0x7f; // max byte hex valueshort s = 0x7fff; // max short hex valueif literal value greater than the max value, we should do the conversion explicately.boolean 是 boolean， 不能直接把 int 和 boolean 对等， if（int）是错的！System.out.println(Integer.MAX_VALUE); //2的31次方-1,10个数位，正的20亿左右,用在钱上面不一定够System.out.println(Integer.MIN_VALUE); //负的2的31次方System.out.println(Long.MAX_VALUE); //2的64次方-1,19个数位，很大了,可放心用在钱上面System.out.println(Long.MIN_VALUE); //负的2的64次方System.out.println(Float.MAX_VALUE); //2的128次方-1,38个数位，比long多了一倍,这个主要用来做简单数学精确运算使用System.out.println(Float.MIN_VALUE); //2的-149次方System.out.println(Double.MAX_VALUE); //2的1024次方-1,308个数位，是float数位的10倍，主要用来做复杂运算和天文运算System.out.println(Double.MIN_VALUE); //2的-1074次方 对基本数据类型执行算术运算，位移运算和位运算，大家会发现，只要它们“比int 小”（即char、byte或者short），那么在运算之前，这些值会自动转换成int。如果将一个float 值与一个double 值相乘，结果就是double；如果将一个int 和一个long 值相加，则结果为long。int/long with float will be float, int/long with double will be doulbe.switch只能支持 byte、short、char、int或者其对应的封装类以及Enum类型, jdk1.7 支持string.在构造器里调用其他构造器： (!!!)this() 必须写在第一行， 像 super().构造器里可以调用final或者private方法。override and hide(just static function can hide) require the same function signature and return type, but overload does not require the same return type(the arguments are different by default).为何要用finalize(): (!!!)一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize( )方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。看来之所以要有finalize()，是由于你可能在分配内存时，采用了类似C语言中的做法而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下，它是在Java中调用非Java代码的一种方式。在非Java代码中，也许会调用类似C的malloc()函数，用它分配存储空间，而且除非调用了free()函数，否则存储空间将不会得到释放，从而造成内存泄露。当然，free()是C和C++中的函数，所以你需要在finalize()中用本地方法调用它。在这里有必要总结一下对象的创建过程。请考虑一个名为Dog 的类：(1) 类型为Dog 的一个对象首次创建时，或者Dog 类的static 方法／static 字段首次访问时，Java解释器必须找到Dog.class（在事先设好的类路径里搜索）。(2)找到Dog.class后（它会创建一个Class对象,这将在后面学到）它的所有static 初始化模块都会运行。因此，static初始化仅发生一次——在Class对象首次载入的时候。(3)创建一个newDog()时，Dog对象的构建进程首先会在内存堆（Heap）里为一个Dog 对象分配足够多的存储空间。(4)这种存储空间会清为零，将Dog中的所有基本类型设为它们的默认值（零用于数字，以及boolean 和 char的等价设定）。(5) 进行字段定义时发生的所有初始化都会执行。(6)执行构建器。正如第6章将要讲到的那样，这实际可能要求进行相当多的操作，特别是在涉及继承的时候。例子为StaticInitialization在netbeans的test包里面final field can be blank final, but must be initialized in constructor or initializing block.final方法的第二个原因是效率。如果你将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌（inline）调用。接口的方法名字和参数类型与父类的方法名字和参数类型一样时，返回类型也要一样。 多个接口的方法名字和参数类型一样时，他们的返回类型也要一样。你不能在接口内部放置任何代码，但嵌套类（static inner class）可以作为接口的一部分，因为它是static 的。当你继承了某个外围类的时候，内部类会被继承，但是“重载”内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当你在外部继承某个内部类的时候（extends outer.inner），要用new outer().super()来初始化父内部类.内部类的名字与外部的某个类名字相同， 在此类中外部类会被隐藏！注意，内部类的名字不能与它所在的类同名！inner_class&package_inheritance.Main 关于inf内部类的奇怪现象闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包。用闭包实现回调。内部类实现接口，可以防止接口的方法和继承下来的方法相冲突（名字参数相同）。一旦catch 子句结束，则处理程序的查找过程结束。注意，只有匹配的catch 子句才能得到执行；这与switch 语句不同，switch 语句需要你在每一个case 后面跟一个break，以避免执行后续的case子句。当你重载方法的时候，你只能抛出在父类方法的异常说明里列出的那些异常，或者抛出派生的异常，又或者不抛也行！在继承和重载的过程中，方法的“异常说明的接口”不是变大了而是变小了.构造函数的异常可以随便添加或者删除！方法原型是由方法的名字与参数的类型组成的,不能根据异常说明的不同来重载方法用RuntimeException 来包装‘被检查的异常’所以RTTI和反射之间真正的区别只在于，对RTTI来说，编译器在编译期打开和检查.class文件。（换句话说，我们可以用“普通”方式调用一个对象的所有方法。）而对于反射机制来说.class文件在编译期间是不可获取的，所以是在运行期打开和检查.class文件。Object 的hashCode()方法生成散列码，而它默认是使用对象的地址计算散列码。默认的 Object.equals()只是比较对象的地址.正确的 equals()方法必须满足下列5 个条件：1.自反性：对任意 x，x.equals(x)一定返回true。2.对称性：对任意x 和y，如果y.equals(x)返回true，则x.equals(y)也返回true。3.传递性：对任意x，y，z，如果有x.equals(y)返回ture，y.equals(z)返回true，则x.equals(z)一定返回true。4.一致性：对任意 x 和y，如果对象中用于等价比较的信息没有改变，那么无论调用x.equals(y)多少次，返回的结果应该保持一致，要么一直是true，要么一直是false。5.对任何不是 null 的x，x.equals(null)一定返回false。设计 hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该生成同样的值。如果在将一个对象用put()添加进HashMap 时，产生一个hashCode()值，而用get()取出时，却产生了另一个hashCode()值，那么你就无法重新取得该对象了。不应该使 hashCode()只依赖于具有唯一性的对象信息，比如内存地址！String 有个特点：如果程序中有多个String 对象，都包含相同的字符串序列，那么这些String 对象都映射到同一块内存区域hashCode：1. 给 int 变量result 赋予某个非零值常量，例如17。2.为对象内每个有意义的属性 f（即每个可以作equals()操作的属性）计算出一个int 散列码c：boolean ： c = (f ? 0 : 1)byte, char, short, or int：  c = (int)flong ：	c = (int)(f ^ (f >>>32))float ： c = Float.floatToIntBits(f);double ： long l = Double.doubleToLongBits(f); c = (int)(l ^ (l >>> 32))Object ： c = f.hashCode( )  (equals 要调用 Object.equals())数组 ： 对每个元素应用上述规则1. 合并计算得到的散列码：result = 37 * result + c;2.返回 result3.检查 hashCode()最后生成的结果，确保相同的对象有相同的散列码。equals:public boolean equals(Object o)return (o instanceof CountedString)&& s.equals(((CountedString)o).s)&& id == ((CountedString)o).id; CountedString只有string s和int id。负载因子(load factor)=size/capacity轻负载(小负载)的散列表具有冲突少、适宜插入与查询的特点（但是使用迭代器遍历会变慢）较高的负载因子在降低空间需求的同时，会提高查询的时间开销，而查询是你用得最多的操作（get()与put()中都用到查询）选择接口的不同实现： LIST SET MAPLIST: arraylist access ;  linkedlist modifySET: hashset always better than treeset, want to get ordered set, use treesetMAP: hashmap always better than treemap, want to get ordered set, use treesetCollection 接口包含有“可选择”的方法（Java容器类的某些接口也是如此），而实现了容器接口的“具体类”可能“支持”，也可能不“支持”这种“可选择”的方法。调用不被支持的方法会引发UnsupportedOperationException 异常此外，大多数以Collection 为参数的方法，只是读取Collection 的内容，而Collection 的“读”方法都不是“可选择”的。例子：Arrays.asList()生成一个List， 并不能访问所有接口。对于已存在的线程，你可以用getPriority()方法得到其优先权，也可以在任何时候使用setPriority()方法更改其优先权.唯一可移植的策略是当你调整优先级的时候，只使用MAX_PRIORITY，NORM_PRIORITY，和MIN_PRIORITY三种级别当所有的非后台线程结束，程序也就终止了。反过来说，只要有任何非后台线程还在运行，程序就不会终止.你必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。。如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程.intrupt 可以停止 sleep wait join！ 当另一个线程在该线程上调用interrupt( )时，将给该线程设定一个标志，表明该线程已经被中断。然而，异常被捕获时将清除这个标志，所以在异常被捕获的时候这个标志总是为假 (!!!)线程状态：new, runnable, blocked, terminated, running(not included in Thread.State)哲学家筷子吃饭问题：（死锁产生的四个必要条件）1．互斥条件：线程使用的资源中至少有一个是不能共享的。这里，一根筷子一次就只能被一个哲学家使用。2．至少有一个进程持有一个资源，并且它在等待获取一个当前被别的进程持有的资源。也就是说，要发生死锁，哲学家必须拿着一根筷子并且等待另一根。3．资源不能被进程抢占。所有的进程必须把资源释放作为普通事件。哲学家很有礼貌，他们不会从其他哲学家那里抢筷子。4．必须有循环等待，这时，一个进程等待其它进程持有的资源，后者又在等待另一个进程持有的资源，这样一直下去，直到有一个进程在等待第一个进程持有的资源，使得大家都被锁住。